/*
 * $Id: ForensicLucid.jjt,v 1.12 2013/08/26 21:14:43 mokhov Exp $
 */

/*
 * OPTIONS
 */

options 
{
	USER_TOKEN_MANAGER = false;
	USER_CHAR_STREAM = false;

	// Does not generate nodes for non-terminals automatically
	NODE_DEFAULT_VOID = true; 

	//LOOKAHEAD = 6;
	//FORCE_LA_CHECK = true;
	STATIC = false;
	//VISITOR = true;
	//MULTI = true;
}

/*
 * COMPILATION PART
 */

PARSER_BEGIN(ForensicLucidParser)
package gipsy.GIPC.intensional.SIPL.ForensicLucid;
import gipsy.GIPC.intensional.SimpleNode;
import gipsy.GIPC.util.Node;
import gipsy.GIPC.util.ParseException;
import gipsy.GIPC.util.SimpleCharStream;
import gipsy.GIPC.util.Token;
import gipsy.GIPC.util.TokenMgrError;
import gipsy.interfaces.AbstractSyntaxTree;
import marf.util.Debug;
import java.util.*;
import gipsy.storage.Dictionary;


/**
 * Does syntactic analysis, outputs an AST. Focuses on the ForensicLucid.
 * Generated by JavaCC automatically.
 *
 * @author Serguei A. Mokhov
 * @version $Id: ForensicLucid.jjt,v 1.12 2013/08/26 21:14:43 mokhov Exp $
 * @see ForensicLucidTreeConstants Provides the constants definition for an AST.
 * @see ForensicLucidConstants     Provides the constants definition for parser.
 */
public class ForensicLucidParser 
{
	/**
	 * Error count.
	 */
	private int iErrorCount = 0;
	
	/**
	 * Parses a ForensicLucid program and produces its AST.
	 * @return abstract syntax tree if parse was successful; null otherwise.
	 */
	public AbstractSyntaxTree parse()
	{
		try
		{
			System.err.println("ForensicLucid Parser Version $Revision: 1.12 $");

			//Dictionary oForensicLucidParseDictionary = new Dictionary();

			/* the start state */
			SimpleNode oRoot = startParse();
			System.err.println("Syntactic Errors: " + this.iErrorCount);
			return new AbstractSyntaxTree(oRoot);
		}
		catch(ParseException e)
		{
			System.err.println(e);
			e.printStackTrace(System.err);
			return null;
		}
	}
	
	/**
	 * Retrieves number of parse errors.
	 * @return error count
	 */
	public int getErrorCount()
	{
		return this.iErrorCount;
	}
	
	/**
	 * Re-arranges tree structure for binary operators for poNodeOp (operator) to be the root.
	 * @return resulting parent node
	 */
	public static SimpleNode biOp(SimpleNode poNode1, SimpleNode poNodeOp, SimpleNode poNode3)
	throws ParseException
	{
		poNode1.jjtSetParent(poNodeOp);
		poNode3.jjtSetParent(poNodeOp);
		poNodeOp.jjtAddChild(poNode3, 0);
		poNodeOp.jjtAddChild(poNode1, 1);
		
		return poNodeOp;
	}

	/**
	 * #Qlist is the list that contains several Qs, these Qs are
	 * made children to the #where node.
	 * @return resulting parent #where node
	 */
	public static SimpleNode where(SimpleNode poNode1, SimpleNode poWhereNode, SimpleNode poNode3)
	throws ParseException
	{
		poNode3.jjtSetParent(poWhereNode);
		poWhereNode.jjtAddChild(poNode3, 0);
		
		if(poNode1.children != null)
		{
			int i = poNode1.children.length;
			Node oInterNode;

			for(int j = 0; j < i; j++)
			{
				oInterNode = poNode1.children[j];
				oInterNode.jjtSetParent(poWhereNode);
				poWhereNode.jjtAddChild(oInterNode, j + 1);
			}
		}
		
		return poWhereNode;
	}
}
PARSER_END(ForensicLucidParser)


/****************** TOKEN DECLARATION ********************/

SKIP : /* WHITE SPACE */
{
	  " "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
	  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| <FORMAL_COMMENT:      "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
 	| <MULTI_LINE_COMMENT:  "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">

 	// Treat #FORENSICLUCID language tag as comment if fed directly
 	| <FORENSICLUCID_COMMENT:  "#FORENSICLUCID" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
	  <DIMENSION: "dimension">
	| <END:       "end">
	| <IF:        "if">
	| <THEN:      "then">
	| <ELSE:      "else">
	| <FI:        "fi">
	| <WHERE:     "where">

	// JLucid
	| <EMBED:     "embed">
	
	// Lucx: this is used in the declaration section to indicate that the tag type is int.
	| <INT:       "int">

	// Lucx: This is used in tag set type expressions {1...100}
	| <TO:        "to">
	
	// Lucx: This is used in tag set type expressions {1...100 /2}
	| <STEP:      "step"> 
	
	// Lucx: Following is the reserved Lucx words for tag set types
	| <ORDERED:     "ordered">
	| <UNORDERED:   "unordered">
	| <FINITE:      "finite">
	| <INFINITE:    "infinite">
	| <PERIODIC:    "periodic">
	| <NONPERIODIC: "nonperiodic"> 
	| <ENUMERATED:  "enumerated">
	| <UPPER:       "upper">
	| <LOWER:       "lower">
	| <PLUSINF:     "INF+">
	| <MINUSINF:    "INF-">
	
	// Forensic Lucid specific
	| <OBSERVATION:         "observation">
	| <OBSERVATIONSEQUENCE: "observation sequence">
	| <EVIDENTIALSTATEMENT: "evidential statement">
	| <NOOBSERVATION:       "$">
	| <ZEROOBSERVATION:     "\\0">
	
	| <TRUE:  "true">
	| <FALSE: "false">
	| <BOD:   "bod">
	| <EOD:   "eod">
}

TOKEN : /* OPERATORS */
{
	/* regular operations */

	  <ASSIGN: "=">
	| <GT:     ">">
	| <LT:     "<">
	| <EQ:     "==">
	| <LE:     "<=">
	| <GE:     ">=">
	| <NE:     "!=">
	| <OR:     "or">
	| <AND:    "and">
	| <NOT:    "not">
	| <BITAND: "&">
	| <BITOR:  "|">
	| <PLUS:   "+">
	| <MINUS:  "-">
	| <STAR:   "*">
	| <SLASH:  "/">
	| <REM:    "%">

	// Forensic Lucid
	| <XOR:    "xor">
	| <NEG:    "neg">
	| <ANDAND: "&&">
	| <OROR:   "||">
	| <MAPTO:  "=>">

	/* binop */

	// Classic
	| <ASA:  "asa">
	| <FBY:  "fby">
	| <UPON: "upon">
	| <WVR:  "wvr">

	// Forensic Lucid
	| <ALA:     "ala">
	| <PBY:     "pby">
	| <RUPON:   "rupon">
	| <NUPON:   "nupon">
	| <NRUPON:  "nrupon">
	| <RWVR:    "rwvr">
	| <NWVR:    "nwvr">
	| <NRWVR:   "nrwvr">
	| <NASA:    "nasa">
	| <NALA:    "nala">

	| <COMBINE: "combine">
	| <PRODUCT: "product">
	| <BEL:     "bel">
	| <PL:      "pl">

	// The following are Lucx-added biops
    | <ISSUBCONTEXT: "\\isSubContext"> //context c1 contains context c2 
	| <DIFFERENCE:   "\\difference">
	| <INTERSECTION: "\\intersection">
	| <UNION:        "\\union">
	
	| <ISDIMENSIONINCONTEXT: "\\isDimensionInContext">
	| <ISTAGINCONTEXT:       "\\isTagInContext">
	
	| <EXTRACT:         "\\extract">
	| <OVERRIDE:        "\\override">
	| <PROJECTION:      "\\projection">
	| <HIDING:          "\\hiding">	
	| <SUBSTITUTION:    "\\substitution">	
	| <CHOOSE:          "\\choose">	
	| <UNDIRECTEDRANGE: "\\undirectedRange">
	| <DIRECTEDRANGE:   "\\directedRange">

	// Forensic Lucid
	| <ISIN:            "\\in">

	/* unop */

	// Classic
	| <FIRST: "first">
	| <NEXT:  "next">
	| <PREV:  "prev">
	| <ISEOD: "iseod">

	// Forensic Lucid
	| <ISBOD:   "isbod">
	| <SECOND:  "second">
	| <LAST:    "last">
	| <PRELAST: "prelast">
	
	// The following are the Lucx-added unops
	| <GETDIM:  "\\getdim">
	| <GETTAG:  "\\gettag">
	| <ISEMPTY: "\\isEmpty">
	| <ISBOX:   "\\isBox">
    | <ISSET:   "\\isSet">

	/* base */	

	// GIPL
	| <AT:   "@">
	| <WHEN: "#">

	// Lucx
	| <BOX:   "box">
	| <EMPTY: "empty"> // indicates the empty set
}

TOKEN : /* LITERALS */
{
  <INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
| <#OCTAL_LITERAL: "0" (["0"-"7"])*>
| <FLOATING_POINT_LITERAL:
	    (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
	  | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
	  | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
	  | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| <CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
| <STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/*
 * NOTE: need to keep this one in sync with:
 *   GIPL.jjt, Lucx.jjt, and PreprocessorParser.jjt.
 *   JGIPL.jjt and JForensicLucid.jjt are generated.
 */
TOKEN : //The complex tokens. 

/* IDENTIFIERS */
{
	<ID: <LETTER> (<LETTER>|<DIGIT>)*>

	| <#LETTER:
		[
			"\u0024",
			"\u0041"-"\u005a",
			"\u005f",
			"\u0061"-"\u007a",
			"\u00c0"-"\u00d6",
			"\u00d8"-"\u00f6",
			"\u00f8"-"\u00ff",
			"\u0100"-"\u1fff",
			"\u3040"-"\u318f",
			"\u3300"-"\u337f",
			"\u3400"-"\u3d2d",
			"\u4e00"-"\u9fff",
			"\uf900"-"\ufaff"
		]
	  >

	| <#DIGIT:
		[
			"\u0030"-"\u0039",
			"\u0660"-"\u0669",
			"\u06f0"-"\u06f9",
			"\u0966"-"\u096f",
			"\u09e6"-"\u09ef",
			"\u0a66"-"\u0a6f",
			"\u0ae6"-"\u0aef",
			"\u0b66"-"\u0b6f",
			"\u0be7"-"\u0bef",
			"\u0c66"-"\u0c6f",
			"\u0ce6"-"\u0cef",
			"\u0d66"-"\u0d6f",
			"\u0e50"-"\u0e59",
			"\u0ed0"-"\u0ed9",
			"\u1040"-"\u1049"
		]
	  >
}  /* Suppose they are UNICODE */

TOKEN : /* SEPARATORS */
{
	  <LPAREN:    "(">
	| <RPAREN:    ")">
	| <LBRACKET:  "[">
	| <RBRACKET:  "]">
	| <LCURB:     "{">
	| <RCURB:     "}">
	| <SEMICOLON: ";"> 
	| <COMMA:     ",">
	| <DOT:       ".">
	| <COLON:     ":">
}
 
TOKEN :  /* ILLEGAL CHARACTERS */ 
{
	// XXX: review; % -> mod, ^ for power, `` for EMBED
	<ILLEGALCHAR: ["~", "%", "^", "`"]>
	/* { System.err.println("illegal char occur"); } */
}	/* in the future, use unicode to express all illegal chars */


/**************** COMMON TOKEN ACTION  ****************/

TOKEN_MGR_DECLS :
{
	int iCount = 0;
	
	void commonTokenAction(Token poToken)
	{
		System.out.println(poToken.image);
	}
}


/******************* SYNTAX  ******************/

/**
 * Counts errors during parsing.
 */
JAVACODE void countErrors()
{
	this.iErrorCount++;
}

JAVACODE SimpleNode sign(SimpleNode node1, SimpleNode node2) 
{
	node1.jjtSetParent(node2);
	node2.jjtAddChild(node1, 0);
	return node2;
}

JAVACODE SimpleNode function(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4) 
{
	node4.jjtSetParent(node1);
	node3.jjtSetParent(node1);
	node2.jjtSetParent(node1);
	node1.jjtAddChild(node4, 0);
	node1.jjtAddChild(node3, 1);
	node1.jjtAddChild(node2, 2);
	return node1;
}

JAVACODE SimpleNode uniOp(SimpleNode node1, SimpleNode node2) //E,uniOp
{
	node1.jjtSetParent(node2);
	node2.jjtAddChild(node1, 0);
	return node2;
}


// this is for sipl, gipl doesn't need this function
// node1-4: if, 1st, 2nd, 3rd paras
JAVACODE SimpleNode ifClause(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4)  
{
	node2.jjtSetParent(node1);
	node3.jjtSetParent(node1);
	node4.jjtSetParent(node1);
	node1.jjtAddChild(node2, 0);
	node1.jjtAddChild(node3, 1);
	node1.jjtAddChild(node4, 2);

	return node1;
}

JAVACODE SimpleNode makeQlist(SimpleNode child, SimpleNode parent) 
{
	child.jjtSetParent(parent);

	if(parent.children != null)
	{
	    parent.jjtAddChild(child, parent.children.length);
	}
	else
	{
	    parent.jjtAddChild(child, 0);
	}

	return parent;
}

// left, =, right
JAVACODE SimpleNode assign(SimpleNode node1, SimpleNode node2, SimpleNode node3)
{
	node1.jjtSetParent(node2);
	node3.jjtSetParent(node2);
	node2.jjtAddChild(node1, 0);
	node2.jjtAddChild(node3, 1);

	return node2;
}

SimpleNode startParse() #START : {}
{
	try 
	{ 
		E() <EOF>
		{
			return jjtThis;
		}
	}
	catch(ParseException e) 
	{
		countErrors();
		System.err.println("ForensicLucid Parser: " + e.toString()); 
	}
}

/**
 * Main grammar expression.
 */
void E() : {}
{
	try
	{
		LOOKAHEAD(100)
		( ID() <ASSIGN> E()E1() ) #ASSIGN E1()
		
		|
		( <IF> E() <THEN> E() <ELSE> E() <FI> ) #IF E1()
		
		|
		( <WHEN>  E() ) #HASH E1()
		
		|
		Term() E1()
		
		|
		LOOKAHEAD(100000000)
		( ( <PLUS> #POSI | <MINUS> #NEGE ) Term() )
		{
			SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // Term
			SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // sign
			SimpleNode node = sign(midNode1, midNode2);
			jjtree.pushNode(node);
		}
		E1()

		// Bounds
		|
		( <EOD> #EOD | <BOD> #BOD | <PLUSINF> #PLUSINF | <MINUSINF> #MINUSINF )  E1()

		|
		( <TRUE> #TRUE | <FALSE> #FALSE )  E1()

		|
		embed() E1()
		
		/*
		 * The below comment is special and should be
		 * used by grammar-grammar generators, such as JGIPL.sh
		 * to insert new productions. When replacing, it's probably
		 * a good idea to re-isert the special comment again if
		 * there planned to be some further processing
		 */
		//{EXTEND-E}
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println("ForensicLucid Parser: " + e.toString()); 
	}
}

void E1() : {}
{
	try
	{
		
		[
			( ( "+" #ADD | "-" #MIN | "or" #OR | "xor" #XOR ) Term() )
			{
				SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right (Term in this production)
				SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // #biOp
				SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left(Term in E -> Term E1)

				SimpleNode node = biOp(midNode1, midNode2, midNode3);

				jjtree.pushNode(node);
			}
			E1() 
  
			|
			( ( "<" #LT | ">" #GT | ">=" #GE | "<=" #LE | "==" #EQ | "!=" #NE ) E() )
			{
				SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right
				SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // relOp
				SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
				
				SimpleNode node=biOp(midNode1, midNode2, midNode3);
				
				jjtree.pushNode(node);
			}
			E1()
 
			|
			( <AT> #AT E() | <DOT> #DOT E() )
			{
				SimpleNode oRightArg = (SimpleNode)jjtree.popNode(); // right
				SimpleNode oOpNode   = (SimpleNode)jjtree.popNode(); // at | "."
				SimpleNode oLeftArg  = (SimpleNode)jjtree.popNode(); // left

				SimpleNode oResultNode = biOp(oRightArg, oOpNode, oLeftArg);
				
				jjtree.pushNode(oResultNode);
			}
			E1()

			|
			( "where" #WHERE Q() #Qlist "end" )
			{
				SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // #Qlist
				SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // #Where
				SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left (E)
				
				SimpleNode node = where(midNode1, midNode2, midNode3);
				
				jjtree.pushNode(node);
			}
			E1()

			|
			( Tail() )
			{
				SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // #FUN
				SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // #paras
				SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // #dim
				SimpleNode midNode4=(SimpleNode) jjtree.popNode(); // #ID(function name)
				SimpleNode node=function(midNode1, midNode2, midNode3, midNode4);
				jjtree.pushNode(node);
			}
			E1()

			|
			(
				(
					// Classic
					  ( "fby" #FBY )
					| ( "wvr" #WVR )
					| ( "asa" #ASA )
					| ( "upon" #UPON )

					// Forensic Lucid
					| ( "ala" #ALA )
					| ( "pby" #PBY )
					| ( "rupon" #RUPON )
					| ( "nupon" #NUPON )
					| ( "nrupon" #NRUPON )
					| ( "rwvr" #RWVR )
					| ( "nwvr" #NWVR )
					| ( "nrwvr" #NRWVR )
					| ( "nasa" #NASA )
					| ( "nala" #NALA )
				)
				E()
			)
			{
				SimpleNode oMidNode1 = (SimpleNode)jjtree.popNode(); // E / id-right
				SimpleNode oMidNode2 = (SimpleNode)jjtree.popNode(); // lucidop, e.g. fby
				SimpleNode oMidNode3 = (SimpleNode)jjtree.popNode(); // left
				
				SimpleNode oNode = biOp(oMidNode1, oMidNode2, oMidNode3);
				
				jjtree.pushNode(oNode);
			}
			E1()

			//{EXTEND-E1}
	
	/*
	|( ( <ISDIMENSIONINCONTEXT> #ISDIMENSIONINCONTEXT ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right-context
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // ISPART
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left-dimension ID
	   
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

	E1()
	
	|( ( <ISTAGINCONTEXT> #ISTAGINCONTEXT ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right-context
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // ISPART
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left-dimension ID
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

	E1()
	*/
		]
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());
	}
}

// Modified
void Tail() : {}
{
	try
	{
		<LBRACKET> (( E() ( <COMMA> E() )* ) #DIM <RBRACKET> <LPAREN> ( E() ( <COMMA> E() )* ) #PARAS) <RPAREN> #FUN
		| <LPAREN> (( E() ( <COMMA> E() )* ) #PARAS) <RPAREN> #FUN
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());
		e.printStackTrace(System.err);
	}
}

void Term() : {}
{
	factor() Term1()
}

void Term1() : {}
{
	[
		LOOKAHEAD(100)
		( (   "*" #TIMES
			| "/" #DIV
			| "%" #MOD
			| "and" #AND
			| <EXTRACT> #EXTRACT
			| <OVERRIDE> #OVERRIDE
			| <PROJECTION> #PROJECTION
			| <HIDING> #HIDING
			| <DIFFERENCE> #DIFFERENCE
			| <SUBSTITUTION> #SUBSTITUTION
			| <INTERSECTION> #INTERSECTION
			| <UNION> #UNION
			| <CHOOSE> #CHOOSE
			| <ISSUBCONTEXT> #ISSUBCONTEXT
			| <ISIN> #ISIN
			| <UNDIRECTEDRANGE> #UNDIRECTEDRANGE
			| <DIRECTEDRANGE> #DIRECTEDRANGE
		) Term() )
		{ 
			SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // right
			SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // biOp
			SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); // left
//	   if(!(midNode1.toString().equals(midNode3.toString())))
//	   {
//	   	   System.err.println("Semantic Error at line " + token.beginLine + ", column " + token.next.beginColumn+": Two operands must be of the same type.");
//	       countErrors();
//	   }
			SimpleNode node=biOp(midNode1, midNode2, midNode3);
			jjtree.pushNode(node);
		}
		Term1()
	]
}

void factor() : {}
{
	  ID()
	| INTEGER()
	| FLOAT()
	| STRING()
	| LOOKAHEAD(100) ARRAY()
	| LOOKAHEAD(100000000) <LPAREN> E() <RPAREN>
	| LOOKAHEAD(100000000) ( <NOT> <LPAREN> E() <RPAREN> ) #NOT
	| LOOKAHEAD(100000000) unary()
	| LOOKAHEAD(100000000) context_simple()
	| LOOKAHEAD(100000000) context_set()
	//| context_box()
	| LOOKAHEAD(100000000) context_forensic()
	//{EXTEND-FACTOR}
}

void unary() : {}
{
	(
		( <FIRST> #uniOp )
		| ( <NEXT> #NEXT )
		| ( <PREV> #PREV )

		// Forensic Lucid
		| ( <SECOND> #SECOND )
		| ( <LAST> #LAST )
		| ( <PRELAST> #PRELAST )
		
		| ( <BEL> #BEL )
		| ( <PL> #PL )
	) E()
	{
		SimpleNode oMidNode1 = (SimpleNode)jjtree.popNode(); // E
	    SimpleNode oMidNode2 = (SimpleNode)jjtree.popNode(); // uniOp
		SimpleNode oNode = uniOp(oMidNode1, oMidNode2);
		jjtree.pushNode(oNode);
	}

	| ( <ISEOD> <LBRACKET> E() ( <COMMA> E() )* <RBRACKET> <LPAREN>  E() <RPAREN> ) #ISEOD
	| ( <ISBOD> <LBRACKET> E() ( <COMMA> E() )* <RBRACKET> <LPAREN>  E() <RPAREN> ) #ISBOD

	// Lucx unary operators
    |
    ( ( <ISEMPTY> #ISEMPTY ) E() )
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); 
		SimpleNode node = uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}

    |
    ( ( <ISSET> #ISSET ) E() )
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); 
		SimpleNode node = uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}
	
	|
	( ( <ISBOX> #ISBOX ) E() )
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); 
		SimpleNode node = uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}
}


void context_simple() : {}
{
	{
		int iCount = 0;
	}

	<LBRACKET>
	(
		context_element(iCount)
		{
			iCount++;
		}

		( <COMMA> context_element(iCount) )*
	) #SIMPLECONTEXT
	<RBRACKET>
}

void context_set() : {}
{
   <LCURB> ( context_simple() ( <COMMA> context_simple() )* ) #CONTEXTSET <RCURB>
}

//void context_box():{}
//     
//{
//      <BOX>  <LPAREN> ID() ID_p() #DEF <COLON> #CONTEXT_BOX E() <RPAREN>
//     {
//     	SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
//		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // context_box
//		SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); // DEF
//		SimpleNode midNode4 = (SimpleNode)jjtree.popNode(); //1st id
//		SimpleNode node = j_context_box(midNode1, midNode2, midNode3, midNode4);
//		jjtree.pushNode(node);
//     } 
//}

void context_element(int pcount) : {}
{
	E() <COLON> #CONTEXT_ELEMENT E()
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); //E()
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); //#CONTEXT_ELEMENT
		SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); //E()
		
		midNode3.jjtSetParent(midNode2);
		midNode1.jjtSetParent(midNode2);
		midNode2.jjtAddChild(midNode3, 0);
		midNode2.jjtAddChild(midNode1, 1);
		
		if
		(
			pcount != 0
			&&
			((SimpleNode)jjtree.peekNode()).jjtGetChild(0).toString().equals
			(
				((SimpleNode)midNode2).jjtGetChild(0).toString()
			)
		)
		{
			System.err.println
			(
				"Semantic error at line:" + token.beginLine
				+ ", column " + token.next.beginColumn + ".\n"
				+ "Duplicate dimension ID: this is not a simple context!"
			);
			this.countErrors();
		}
		
		jjtree.pushNode(midNode2);
	}
}

void context_forensic() #FORENSICCONTEXT : {}
{
	propertyExtra()
	
	|
	LOOKAHEAD(300)
	observationSequenceGeneral()
	
	|
	LOOKAHEAD(300)
	evidentialStatementGeneral()

// 	{
// 		int iCount = 0;
// 	}
// 
// 	<LBRACKET>
// 	(
// 		context_element(iCount)
// 		{
// 			iCount++;
// 		}
// 
// 		( <COMMA> context_element(iCount) )*
// 	) #SIMPLECONTEXT
// 	<RBRACKET>
// 
// // void context_set() : {}
// 
// 	<LCURB> ( context_simple() ( <COMMA> context_simple() )* ) #CONTEXTSET <RCURB>
}

void Q() : {}
{
	try
	{
		(
			// GIPL + Lucx
			( ( <DIMENSION> ID() [ <COLON> tagset() ] <SEMICOLON> ) #DIMENSION )
			
			// Forensic Lucid
			|
			( ( <OBSERVATION> ID() [ <ASSIGN> observedProperty() ] <SEMICOLON> ) #OBSERVATION )
			//( ( <OBSERVATION> ID() [ <ASSIGN> tagset() ] <SEMICOLON> ) #OBSERVATION )

			|
			( ( <OBSERVATIONSEQUENCE> ID() [ <ASSIGN> observationSequence() ] <SEMICOLON> ) #OBSERVATIONSEQUENCE )

			|
			( ( <EVIDENTIALSTATEMENT> ID() [ <ASSIGN> evidentialStatement() ] <SEMICOLON> ) #EVIDENTIALSTATEMENT )

			// Original GIPL
			//|  (( ID()  QTail() <ASSIGN> E() <SEMICOLON> ) #ASSIGN)

			// Lucx
			| E() <SEMICOLON>
	    )
	    ( LOOKAHEAD(100) Q() )*
	}
	catch(ParseException e)
	{
		countErrors();
		
		System.err.println(e.toString());

		// Skip tokens to the next semicolon
		Token oToken;
		do
		{
			oToken = getNextToken();
		}
		while(oToken.kind != SEMICOLON);
	}
}

/**
 * Original GIPL.
 */
void QTail() : {} // [] means that the production can be null or the content in [].
{
	try
	{
		[<LBRACKET> ( ID() ( <COMMA> ID() )* ) #DIM <RBRACKET> <LPAREN> ( ID() ( <COMMA> ID() )* ) #PARAS <RPAREN> #FUN
		{
			SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // #FUN
			SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // #paras
			SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); // #dim
			SimpleNode midNode4 = (SimpleNode)jjtree.popNode(); // #function name
			midNode4.jjtSetParent(midNode1);
			midNode3.jjtSetParent(midNode1);
			midNode2.jjtSetParent(midNode1);
			midNode1.jjtAddChild(midNode4, 0);
			midNode1.jjtAddChild(midNode3, 1);
			midNode1.jjtAddChild(midNode2, 2);
			jjtree.pushNode(midNode1);
		}
		]
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());

		Token oToken;
		do
		{
			oToken = getNextToken();
		}
		while(oToken.kind != SEMICOLON);
	}
}

/**
 * o = (P, min, max, w, t)
 * o = (P, min, max, w)
 * o = (P, min, max)
 * o = (P, min)
 * o = P
 * o = $ (no-observation)
 * o = \0(P) (zero observation)
 */
void observedProperty() #OBSERVATION : {}
{
	// P (E in general)
	LOOKAHEAD(100)
	property()

	// More specific; for left-recusion resolution on E() in factor()
	| propertyExtra()
}

/**
 * P may have an optionally mapped description to it for reporting.
 */
void property() #PROPERTY : {}
{
	// P | P => "description"
	E() [ <MAPTO> <STRING_LITERAL> ]
	//E1() [ LOOKAHEAD(100000000) <MAPTO> <STRING_LITERAL> ]
}

/**
 * 
 */
void propertyExtra() : {}
{
	// $
	//|
	<NOOBSERVATION> #NOOBSERVATION

	// \0(P)
	| ( <ZEROOBSERVATION> <LPAREN> property() <RPAREN> ) #ZEROOBSERVATION

	// (P, E)          as in (P, min)
	// (P, E, E)       as in (P, min, max)
	// (P, E, E, E)    as in (P, min, max, w)
	// (P, E, E, E, E) as in (P, min, max, w, t)
	//| <LPAREN> property() <COMMA> E() <COMMA> E() <COMMA>  E() <COMMA>  E() <RPAREN>
	| <LPAREN> property() <COMMA> E() #OMIN [ <COMMA> E() #OMAX [ <COMMA>  E() #OWEIGHT [ <COMMA>  E() #OTIME ] ] ] <RPAREN>

	// (P, min, max, w, t)
	//| <LPAREN> property() <COMMA> <INTEGER_LITERAL> <COMMA> <INTEGER_LITERAL> <COMMA> <FLOATING_POINT_LITERAL> <COMMA> ( <INTEGER_LITERAL> | <STRING_LITERAL> ) <RPAREN>
	//| <LPAREN> property() <COMMA> INTEGER() <COMMA> INTEGER() <COMMA> FLOAT() <COMMA> ( INTEGER() | STRING() ) <RPAREN>
}

/**
 * os = o
 * os = {o1, o2, o3, ...}
 */
void observationSequence() #OBSERVATIONSEQUENCE : {}
{
	// o
	LOOKAHEAD(300)
	observedProperty()
	// o
	//| ID()
	// {o1, o2, o3, ...}
	// ( <COMMA> ( ID() | observedProperty() ) )*
	//| [ <ORDERED> [ <FINITE> ] ] <LCURB> ( ID() | observedProperty() )+ <RCURB>
	//| [ <ORDERED> [ <FINITE> ] ] <LCURB> ( observedProperty() )+ <RCURB>
	//| [ <ORDERED> [ <FINITE> ] ] <LCURB> observedProperty() ( <COMMA> observedProperty() )* <RCURB>
	| observationSequenceGeneral()
}

void observationSequenceGeneral() : {}
{
	[ <ORDERED> [ <FINITE> ] ] <LCURB> observedProperty() ( <COMMA> observedProperty() )* <RCURB>
}

/**
 * es = os
 * es = {os1, os2, os3, ...}
 */
void evidentialStatement() #EVIDENTIALSTATEMENT : {}
{
	// os
	LOOKAHEAD(300)
	observationSequence()
	// os
	//| ID()
	// {os1, os2, os3, ...}
	//| [ <UNORDERED> [ <FINITE> ] ] <LCURB> ( ID() | observationSequence() )+ <RCURB>
	//| [ <UNORDERED> [ <FINITE> ] ] <LCURB> ( observationSequence() )+ <RCURB>
	//| [ <UNORDERED> [ <FINITE> ] ] <LCURB> observationSequence() ( <COMMA> observationSequence() )* <RCURB>
	| evidentialStatementGeneral()
}

void evidentialStatementGeneral() : {}
{
	[ <UNORDERED> [ <FINITE> ] ] <LCURB> observationSequence() ( <COMMA> observationSequence() )* <RCURB>
}

/**
 * Lucx's tag sets.
 */
void tagset() : {}
{
	LOOKAHEAD(300)
	[ <ORDERED> ]
	(
		LOOKAHEAD(300)
		[ <FINITE> ]
		(
		  LOOKAHEAD(300)
		  [ <PERIODIC> ]    <LCURB> orderdedFinitePeriodicTagSet()    <RCURB>
		| [ <NONPERIODIC> ] <LCURB> orderdedFiniteNonperiodicTagSet() <RCURB>
		)

		|
		LOOKAHEAD(300)
		[ <INFINITE> ]
		(
		  LOOKAHEAD(300)
		  [ <PERIODIC> ]    <LCURB> orderedInfinitePeriodicTagSet()    <RCURB>
		| [ <NONPERIODIC> ] <LCURB> orderedInfiniteNonperiodicTagSet() <RCURB>
		)
	//| <ORDERED><INFINITE><NONPERIODIC>"{"<MINUSINF><TO><PLUSINF>"}" #ORDEREDFINITENONPERIODICTAGSET_INFINITY
	)
	
	|
	LOOKAHEAD(300)
	[ <UNORDERED> ]
	(
		LOOKAHEAD(300)
		[ <FINITE> ]
		(
		  LOOKAHEAD(300)
		  [ <PERIODIC> ]  <LCURB> unorderedFinitePeriodicTagSet()    <RCURB>
		| [ <NONPERIODIC> ] <LCURB> unorderedFiniteNonperiodicTagSet() <RCURB>
		)

		|
		LOOKAHEAD(300)
		<INFINITE><PERIODIC> <LCURB> unorderedInfinitePeriodicTagSet() <RCURB>
		//| <UNORDERED><INFINITE><NONPERIODIC> "{" unorderedInfiniteNoneriodicTagSet()"}"
	)

	//| observedProperty()

}

// ORDEREDFINITEPERIODICTAGSET
//     /               \
//   PERIOD          TIMES
void orderdedFinitePeriodicTagSet() : {}
{
	( "<" ( E() ( <COMMA> E() )* ) #PERIOD ">" <COLON> INTEGER() #TIMES ) #ORDEREDFINITEPERIODICTAGSET
}

void orderdedFiniteNonperiodicTagSet() : {}
{
	 E() orderdedFiniteNonperiodicTagSet1()
}

void orderdedFiniteNonperiodicTagSet1() : {}
{
	((<TO> E() [<STEP> E()]) #ORDEREDFINITENONPERIODICTAGSET_LOWERUPPER
	|
	(<COMMA>E())* #ORDEREDFINITENONPERIODICTAGSET_ENUMERATED)
	
	{
		adjustPosition();
	}
}

/**
 * It is the method to deal with moving the nodes.
 */
JAVACODE void adjustPosition()
{
	SimpleNode tailE=(SimpleNode)jjtree.popNode(); //this is {2,3}
	SimpleNode firstE =(SimpleNode)jjtree.popNode();// this is 1
	int length=tailE.children.length;
	SimpleNode lastE=(SimpleNode)tailE.children[length-1];
	Vector tailECopy=new Vector(); //copy of all the tailE
	for(int i=0; i<length; i++)
	{
		tailECopy.addElement(tailE.children[i]);
	}

	for(int i=0; i<length; i++)
	{
		SimpleNode tempNode=(SimpleNode)tailECopy.elementAt(i);
		tailE.jjtAddChild(tempNode, i+1); //move the current Es in tailE to the next position in order to insert the firstE as the first child
	}

	tailE.jjtAddChild(firstE, 0);
	jjtree.pushNode(tailE);
}

void orderedInfinitePeriodicTagSet():{}
{
	( "<" (E()(<COMMA>E())*) #PERIOD ">" ) #ORDEREDINFINITEPERIODICTAGSET
}

void orderedInfiniteNonperiodicTagSet() : {}
{
	LOOKAHEAD(100)
	( E() <TO> <PLUSINF> [ <STEP> E() ] ) #ORDEREDINFINITENONPERIODICTAGSET_LOWER
	| ( <MINUSINF> <TO> orderedInfiniteNonperiodicTagSet1() )
	//(<MINUSINF><TO> E() [<STEP> E()])#ORDEREDINFINITENONPERIODICTAGSET_UPPER
//	{
//		adjustPosition();
//	}
}

void orderedInfiniteNonperiodicTagSet1() : {}
{
	LOOKAHEAD(100)
	( E() [ <STEP> E() ] ) #ORDEREDINFINITENONPERIODICTAGSET_UPPER
	| <PLUSINF> #ORDEREDINFINITENONPERIODICTAGSET_INFINITY
}

void unorderedFinitePeriodicTagSet():{}
{
	("<"(E()(<COMMA>E())* ) #PERIOD">" <COLON> INTEGER()#TIMES) #UNORDEREDFINITEPERIODICTAGSET
}

void unorderedFiniteNonperiodicTagSet():{}
{
	(E()(<COMMA>E())*) #UNORDEREDFINITENONPERIODICTAGSET
}

void unorderedInfinitePeriodicTagSet():{}
{
	("<"(E()(<COMMA>E())*) #PERIOD">") #UNORDEREDINFINITEPERIODICTAGSET
}

// Note: Because of the scope issue, we have to put #ID at this position so that jjtThis can work properly
void ID() #ID:
{ 
	Token oToken;
}
{
	// for example, we cannot put #ID over here, or jjtThis will not refer to Node ID.
	oToken = <ID>
	{
		jjtThis.setImage(oToken.image);
	}
}

void INTEGER() #INTEGER:
{
	Token oToken;
}
{
	oToken = <INTEGER_LITERAL>
	{
		jjtThis.setType(0);
		jjtThis.setImage(oToken.image);
	}
}

void FLOAT() #FLOAT:
{
	Token oToken;
}
{
	oToken = <FLOATING_POINT_LITERAL>
	{
		jjtThis.setType(1);
		jjtThis.setImage(oToken.image);
	}
}

void STRING() #STRING:
{
	Token oToken;
}
{
	oToken = <STRING_LITERAL>
	{
		jjtThis.setType(2);
		jjtThis.setImage(oToken.image);
	}
}

/**
 * JLucid embed()
 */
void embed() #EMBED : {}
{
	//<EMBED> <LPAREN> url() E() ( <COMMA> E() )* <RPAREN> <SEMICOLON>
	<EMBED> <LPAREN> url() <COMMA> <STRING_LITERAL> ( <COMMA> E() )* <RPAREN> <SEMICOLON>
}

/**
 * [E, E, E, ...]
 */
void ARRAY() #ARRAY : {}
{
	<LBRACKET> E() ( <COMMA> E() )* <RBRACKET>
}

/**
 * URL -> CHARACTER_LITERAL | STRING_LITERAL.
 */
void url() #URL :
{
	Token oToken;
}
{
	(
		  oToken = <CHARACTER_LITERAL>
		| oToken = <STRING_LITERAL>
	)
	{
		jjtThis.setImage(oToken.image);
	}
}

// EOF
