/*
 * $Id: Lucx.jjt,v 1.9 2007/11/22 22:44:09 x_ton Exp $
 */

/*
 * OPTIONS
 */

options 
{
	USER_TOKEN_MANAGER = false;
	USER_CHAR_STREAM = false;
	NODE_DEFAULT_VOID = true; //Does not generate nodes for non-terminals automatically
	LOOKAHEAD = 6;
	FORCE_LA_CHECK = true;
	STATIC = false;
	//VISITOR = true;
	//MULTI =true;
	NODE_DEFAULT_VOID=true;
}

/*
 * COMPILATION PART
 */

PARSER_BEGIN(LucxParser)
package gipsy.GIPC.intensional.SIPL.Lucx;
import gipsy.GIPC.intensional.SimpleNode;
import gipsy.GIPC.util.Node;
import gipsy.GIPC.util.ParseException;
import gipsy.GIPC.util.SimpleCharStream;
import gipsy.GIPC.util.Token;
import gipsy.GIPC.util.TokenMgrError;
import gipsy.interfaces.AbstractSyntaxTree;
import marf.util.Debug;
import java.util.*;
import gipsy.storage.Dictionary;


/**
 * Does syntactic analysis, outputs an AST. Focuses on the Lucx.
 * Generated by JavaCC automatically.
 *
 * $Id: Lucx.jjt,v 1.9 2007/11/22 22:44:09 x_ton Exp $
 *
 * @author 
 * @version $Revision: 1.9 $
 * @see LucxTreeConstants Provides the constants definition for an AST.
 * @see LucxConstants     Provides the constants definition for parser.
 */
public class LucxParser 
{
	/**
	 * Error count.
	 */
	private int iErrorCount = 0;
	private int semanticErrorCount=0;
	private Dictionary lucxDictionary;
	private int tagsetflag=0;  //this is the flag for different tag set expressions within one tag set type. 
	                          //OrderedFiniteNonperiodic==>0:enumerated {1,2,3}; 1:upper and lower boundary; 2:upper and lower boundary and step
	                         //OrderedInfiniteNonperiodic==>3:upper boudary{...100}; 4:upper boundary with step{...100 /2}; 5:lower boundary{2...}; 6:lower boundary with step{2... /2}; 7:int
	
	
	/**
	 * Parses presumably a Lucx program and produces an AST
	 * @return abstract syntax tree if parse was successful; null otherwise.
	 */
	public AbstractSyntaxTree parse()
	{
		try
		{
			System.err.println("Lucx Parser Version $Revision: 1.9 $");
			lucxDictionary=new Dictionary();
			SimpleNode oRoot = startParse(); /* the start state */
			System.err.println("Syntactic Errors: " + this.iErrorCount);
			return new AbstractSyntaxTree(oRoot);
		}
		catch(ParseException e)
		{
			System.err.println(e);
			e.printStackTrace(System.err);
			return null;
		}
	}
	
	/**
	 * Retrieves number of parse errors.
	 * @return error count
	 * @since Serguei
	 */
	public int getErrorCount()
	{
		return this.iErrorCount;
	}
	

	public static SimpleNode biOp(SimpleNode node1, SimpleNode node2, SimpleNode node3)
	throws ParseException
	{
		node1.jjtSetParent(node2);
		node3.jjtSetParent(node2);
		node2.jjtAddChild(node3, 0);
		node2.jjtAddChild(node1, 1);
		
		return node2;
	}

	public static SimpleNode where(SimpleNode node1, SimpleNode node2, SimpleNode node3) 
	throws ParseException //#Qlist is the list that contains several Qs, these Qs are finally made children to the #where node
	{
		node3.jjtSetParent(node2);
		node2.jjtAddChild(node3, 0);
		
		if(node1.children != null)
		{
			int i = node1.children.length;
			SimpleNode interNode;

			for(int j = 0; j < i; j++)
			{
				interNode = (SimpleNode)node1.children[j];
				interNode.jjtSetParent(node2);
				node2.jjtAddChild(interNode, j+1);
			}
		}
		
		return node2;
	}
	
	
	
}
PARSER_END(LucxParser)



/****************** TOKEN DECLARATION ********************/

SKIP : /* WHITE SPACE */
{
	  " "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
	  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
	| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
	  <DIMENSION: "dimension">
	| <END: "end">
	| <IF: "if">
	| <THEN: "then">
	| <ELSE: "else">
	| <FI: "fi">
	| <WHERE: "where">
	| <INT: "int">  //this is used in the declaration section to indicate that the tag type is int.
	| <TO: "to"> //This is used in tag set type expressions {1...100}
	| <STEP: "step">//This is used in tag set type expressions {1...100 /2}
	
	  // Following is the reserved words for tag set types
	| <ORDERED: "ordered">
	| <UNORDERED: "unordered">
	| <FINITE:"finite">
	| <INFINITE:"infinite">
	| <PERIODIC:"periodic">
	| <NONPERIODIC:"nonperiodic"> 
	| <ENUMERATED: "enumerated">
	| <UPPER: "upper">
	| <LOWER: "lower">
	| <PLUSINF: "INF+">
	| <MINUSINF: "INF-">
	
	
	
	
}

TOKEN : /* OPERATORS */
{
	/* regular operations */

	  <ASSIGN: "=">
	| <GT:     ">">
	| <LT:     "<">
	| <EQ:     "==">
	| <LE:     "<=">
	| <GE:     ">=">
	| <NE:     "!=">
	| <OR:     "or">
	| <AND:    "and">
	| <NOT:    "not">
	| <BITAND: "&">
	| <BITOR:  "|">
	| <PLUS:   "+">
	| <MINUS:  "-">
	| <STAR:   "*">
	| <SLASH:  "/">
	| <REM:    "%">
	
	/* binop */

	| <ASA: "asa">
	| <FBY: "fby">
	| <UPON: "upon">
	| <WVR: "wvr"> 
	
	//The following are some newly added biops
    | <ISSUBCONTEXT: "\\isSubContext"> //context c1 contains context c2 
	| <DIFFERENCE: "\\difference">
	| <INTERSECTION: "\\intersection">
	| <UNION: "\\union">
	
	| <ISDIMENSIONINCONTEXT: "\\isDimensionInContext">
	| <ISTAGINCONTEXT: "\\isTagInContext">
	
	| <EXTRACT: "\\extract">
	| <OVERRIDE: "\\override">
	| <PROJECTION: "\\projection">
	| <HIDING: "\\hiding">	
	| <SUBSTITUTION: "\\substitution">	
	| <CHOOSE: "\\choose">	
	| <UNDIRECTEDRANGE: "\\undirectedRange">
	| <DIRECTEDRANGE: "\\directedRange">
	
	
	/* unop */

	| <FIRST: "first">
	| <NEXT: "next">
	| <PREV: "prev">
	| <ISEOD: "iseod">
	
	//The following are the newly added unops
	| <GETDIM: "\\getdim">
	| <GETTAG: "\\gettag">
	| <ISEMPTY: "\\isEmpty">
	| <ISBOX: "\\isBox">
    | <ISSET: "\\isSet">

	/* base */	

	| <AT: "@">
	| <WHEN: "#">
	
	
	|<BOX: "box">
	|<EMPTY: "empty"> //indicates the empty set
}

TOKEN : /* LITERALS */
{
  <INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
| <#OCTAL_LITERAL: "0" (["0"-"7"])*>
| <FLOATING_POINT_LITERAL:
	    (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
	  | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
	  | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
	  | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| <CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
| <STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )         
        
      )*
      "\""
  >
}

/*
 * NOTE: need to keep this one in sync with:
 *   GIPL.jjt, Lucx.jjt, and PreprocessorParser.jjt.
 *   JGIPL.jjt and JLucx.jjt are generated.
 */
TOKEN : //The complex tokens. 

/* IDENTIFIERS */
{
	<ID: <LETTER> (<LETTER>|<DIGIT>)*>
	

	| <#LETTER:
		[
			"\u0024",
			"\u0041"-"\u005a",
			"\u005f",
			"\u0061"-"\u007a",
			"\u00c0"-"\u00d6",
			"\u00d8"-"\u00f6",
			"\u00f8"-"\u00ff",
			"\u0100"-"\u1fff",
			"\u3040"-"\u318f",
			"\u3300"-"\u337f",
			"\u3400"-"\u3d2d",
			"\u4e00"-"\u9fff",
			"\uf900"-"\ufaff"
		]
	  >

	| <#DIGIT:
		[
			"\u0030"-"\u0039",
			"\u0660"-"\u0669",
			"\u06f0"-"\u06f9",
			"\u0966"-"\u096f",
			"\u09e6"-"\u09ef",
			"\u0a66"-"\u0a6f",
			"\u0ae6"-"\u0aef",
			"\u0b66"-"\u0b6f",
			"\u0be7"-"\u0bef",
			"\u0c66"-"\u0c6f",
			"\u0ce6"-"\u0cef",
			"\u0d66"-"\u0d6f",
			"\u0e50"-"\u0e59",
			"\u0ed0"-"\u0ed9",
			"\u1040"-"\u1049"
		]
	  >
}  /* Suppose they are UNICODE */

TOKEN : /* SEPARATORS */
{
	  <LPAREN: "(">
	| <RPAREN: ")">
	| <LBRACKET: "[">
	| <RBRACKET: "]">
	| <LCURB:"{">
	| <RCURB:"}">
	| <SEMICOLON: ";">  /* Peter suggests omit ';'*/
	| <COMMA: ",">
	| <DOT: ".">
	| <COLON: ":">
}
 
TOKEN :  /* ILLEGAL CHARACTERS */ 
{
	<ILLEGALCHAR: ["~", "%", "^", "`"]>
	/* { System.err.println("illegal char occur"); } */
}	/* in the future, use unicode to express all illegal chars */


/**************** COMMON TOKEN ACTION  ****************/

TOKEN_MGR_DECLS :
{
	int iCount = 0;
	
	void commonTokenAction(Token poToken)
	{
	      System.out.println(poToken.image);
	}
}



/******************* SYNTAX  ******************/

/**
 * Counts errors during parsing.
 */
JAVACODE void countErrors()
{
	this.iErrorCount++;
}




JAVACODE SimpleNode sign(SimpleNode node1, SimpleNode node2) 
{
	node1.jjtSetParent(node2);
	node2.jjtAddChild(node1, 0);
	return node2;
}



JAVACODE SimpleNode function(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4) 
{
	node4.jjtSetParent(node1);
	node3.jjtSetParent(node1);
	node2.jjtSetParent(node1);
	node1.jjtAddChild(node4, 0);
	node1.jjtAddChild(node3, 1);
	node1.jjtAddChild(node2, 2);
	return node1;
}

JAVACODE SimpleNode uniOp(SimpleNode node1, SimpleNode node2) //E,uniOp
{
	node1.jjtSetParent(node2);
	node2.jjtAddChild(node1, 0);
	return node2;
}


// this is for sipl, gipl doesn't need this function
// node1-4: if, 1st, 2nd, 3rd paras
JAVACODE SimpleNode ifClause(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4)  
{
	node2.jjtSetParent(node1);
	node3.jjtSetParent(node1);
	node4.jjtSetParent(node1);
	node1.jjtAddChild(node2, 0);
	node1.jjtAddChild(node3, 1);
	node1.jjtAddChild(node4, 2);

	return node1;
}
		

JAVACODE SimpleNode makeQlist(SimpleNode child, SimpleNode parent) 
{
	child.jjtSetParent(parent);

	if (parent.children!=null)
	    parent.jjtAddChild(child, parent.children.length);
	else 
	    parent.jjtAddChild(child, 0);

	return parent;
}

JAVACODE SimpleNode assign(SimpleNode node1, SimpleNode node2, SimpleNode node3)  // left, =, right
{
	node1.jjtSetParent(node2);
	node3.jjtSetParent(node2);
	node2.jjtAddChild(node1, 0);
	node2.jjtAddChild(node3, 1);

	return node2;
}

SimpleNode startParse() #START : {}
{
	try 
	{ 
		E() <EOF>
		{
			return jjtThis;
		}
	}
	catch(ParseException e) 
	{
		countErrors();
		System.err.println("Lucx Parser: " + e.toString()); 
	}
}





void E() : {}
{
	try
	{
		( ID() <ASSIGN> E()E1() ) #ASSIGN E1()
		
		|( <IF> E() <THEN> E() <ELSE> E() <FI> ) #IF E1() 
		
		|	( <WHEN>  E() ) #HASH E1()
		
		| Term() E1()
		
		|	( ( <PLUS> #POSI | <MINUS> #NEGE ) Term() )
			{
				SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // Term
				SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // sign
				SimpleNode node = sign(midNode1, midNode2);
				jjtree.pushNode(node);
			}
			E1()

		/*
		 * The below comment is special and should be
		 * used by grammar-grammar generators, such as JGIPL.sh
		 * to insert new productions. When replacing, it's probably
		 * a good idea to re-isert the special comment again if
		 * there planned to be some further processing
		 */
		//{EXTEND-E}
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println("Lucx Parser: " + e.toString()); 
	}
}

void E1() : {}
{
  try {

  [    (( "+" #ADD | "-" #MIN | "or" #OR ) Term() ) 

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right (Term in this production)
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // #biOp
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left(Term in E -> Term E1)
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

      E1() 
  
    | (( "<" #LT | ">" #GT | ">=" #GE | "<=" #LE | "==" #EQ | "!=" #NE ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // relOp
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

      E1()
 
    | ( "@" #AT E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right
	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // at
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	  
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }
	 
	 E1()
    
     
  
    | ("where" #WHERE Q() #Qlist  "end" ) 

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // #Qlist
       SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // #Where
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left (E)
	   SimpleNode node=where(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

      E1()

    | ( Tail() ) 

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); //#FUN
       SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // #paras
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // #dim
	   SimpleNode midNode4=(SimpleNode) jjtree.popNode();// #ID(function name)
	   SimpleNode node=function(midNode1, midNode2, midNode3, midNode4);
	   jjtree.pushNode(node);
	 }

      E1()

    | ( ("fby" #FBY) E()) 

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // E
	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // fby
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=biOp(midNode1, midNode2,midNode3);
	   jjtree.pushNode(node);
	 }

	E1()
  
     | ( ( "wvr" #WVR ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // E
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // wvr
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

	E1()

    
      | ( ( "asa" #ASA ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // id-right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // asa
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

	E1()

     |( ( "upon" #UPON ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // id-right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // upon
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

	E1()

	//{EXTEND-E1}
	
	/*
	|( ( <ISDIMENSIONINCONTEXT> #ISDIMENSIONINCONTEXT ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right-context
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // ISPART
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left-dimension ID
	   
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

	E1()
	
	|( ( <ISTAGINCONTEXT> #ISTAGINCONTEXT ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right-context
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // ISPART
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left-dimension ID
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

	E1()
	*/
  ]
  
  }
  catch(ParseException e)
  {
    countErrors();
    System.out.println(e.toString());
  }

}

// Modified
void Tail() : {}
{
	try
	{
		<LBRACKET> (( E() ( <COMMA> E() )* ) #DIM <RBRACKET> <LPAREN> ( E() ( <COMMA> E() )* ) #PARAS) <RPAREN> #FUN
		|<LPAREN> (( E() ( <COMMA> E() )* ) #PARAS) <RPAREN> #FUN
	    
	}
	catch(ParseException e)
	{
	    countErrors();
	    System.err.println(e.toString());
	    e.printStackTrace(System.err);
	}
}

void Term() : {}
{
	factor() Term1()
}

void Term1() :
{ }
{
   [( ( "*" #TIMES | "/" #DIV | "%" #MOD | "and" #AND | <EXTRACT> #EXTRACT | <OVERRIDE> #OVERRIDE |<PROJECTION> #PROJECTION | <HIDING> #HIDING 
   | <DIFFERENCE> #DIFFERENCE | <SUBSTITUTION> #SUBSTITUTION | <INTERSECTION> #INTERSECTION | <UNION> #UNION | <CHOOSE> #CHOOSE 
   | <ISSUBCONTEXT> #ISSUBCONTEXT | <UNDIRECTEDRANGE> #UNDIRECTEDRANGE | <DIRECTEDRANGE> #DIRECTEDRANGE)  Term() ) 

	 { 
	   
	   SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // multOp
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
//	   if(!(midNode1.toString().equals(midNode3.toString())))//	   {//	   	   System.err.println("Semantic Error at line " + token.beginLine + ", column " + token.next.beginColumn+": Two operands must be of the same type.");//	       countErrors();//	   }
	   SimpleNode node=biOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }
			      
   Term1()  ]
}


void factor() : {}
{
	  ID()
	| INTEGER()
	| FLOAT()
	| STRING()
	| <LPAREN> E() <RPAREN>
	| ( <NOT> <LPAREN> E() <RPAREN> ) #NOT
	| unary()
	| context_simple()
	| context_set()
	//| context_box()
	//{EXTEND-FACTOR}
}

void unary() : {}
{
	  ( ( <FIRST> #uniOp ) E())
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode();  // E
	    SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // uniOp
		SimpleNode node = uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}

	
	| ( ( <NEXT> #NEXT ) E())
	{
		SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // E
		SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // next
		SimpleNode node=uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}

	| ( ( <PREV> #PREV ) E())
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // prev
		SimpleNode node = uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}
	// TODO:
	| ( <ISEOD> <LBRACKET> E() ( <COMMA> E() )* <RBRACKET> <LPAREN>  E() <RPAREN> ) #ISEOD

	// | "[" E() "]" ( "fby" | "wvr" | "asa" | "upon" ) #BINOP "[" E() ( "," E())* "]" "(" E() ")"
	// binary operators should move up to production E1, and original grammar should be changed 
	// a little, that is to eliminate the ( and ) around E.


  

    // Newly added unary operators for lucx
    | ( ( <ISEMPTY> #ISEMPTY ) E())
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); 
		SimpleNode node = uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}

    | ( ( <ISSET> #ISSET ) E())
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); 
		SimpleNode node = uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}
	
	| ( ( <ISBOX> #ISBOX ) E())
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); 
		SimpleNode node = uniOp(midNode1, midNode2);
		jjtree.pushNode(node);
	}
	

}


void context_simple():{}     
{
   {
   	  int count=0;
   	  
   }
   <LBRACKET> (context_element(count)
   {
   	  count++;
   }
   
   (<COMMA>context_element(count))*)  #SIMPLECONTEXT <RBRACKET>
}
     
     
  
void context_set():{}
{   
   <LCURB> (context_simple()(<COMMA> context_simple())*) #CONTEXTSET <RCURB>
     
}
     
//void context_box():{}//     //{//      <BOX>  <LPAREN> ID() ID_p() #DEF <COLON> #CONTEXT_BOX E() <RPAREN>//     {//     	SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E//		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // context_box//		SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); // DEF//		SimpleNode midNode4 = (SimpleNode)jjtree.popNode(); //1st id//		SimpleNode node = j_context_box(midNode1, midNode2, midNode3, midNode4);//		jjtree.pushNode(node);//     } //}
		 

void context_element(int pcount): {}
{
     E() <COLON> #CONTEXT_ELEMENT E()
    {
        SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); //E()
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); //#CONTEXT_ELEMENT
		SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); //E()
		midNode3.jjtSetParent(midNode2);
		midNode1.jjtSetParent(midNode2);
		midNode2.jjtAddChild(midNode3, 0);
		midNode2.jjtAddChild(midNode1, 1);
		if(pcount!=0 && ((SimpleNode)jjtree.peekNode()).jjtGetChild(0).toString().equals(((SimpleNode)midNode2).jjtGetChild(0).toString()))
        {
            System.err.println("Semantic error at line:"+ token.beginLine + ", column " + token.next.beginColumn+" Duplicate dimension ID: This is not a simple context!");
            this.countErrors();            
        }
		jjtree.pushNode(midNode2);
    }
}


void Q() : {}
{
	try
	{
		((<DIMENSION> ID() [<COLON> tagset() ] <SEMICOLON> )#DIMENSION )( ( Q() )* )
		
		//|  (( ID()  QTail()  <ASSIGN> E() <SEMICOLON> ) #ASSIGN)  ( ( Q() )* )
	    |E()<SEMICOLON> (Q())*
	
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());
		Token t;
		do
		{
			t = getNextToken();
		}
		while(t.kind != SEMICOLON);
	}
}


void QTail() : {} //[] means that the production can be null or the content in [].
{
	try
	{
		[<LBRACKET> ( ID() ( <COMMA> ID() )* ) #DIM <RBRACKET> <LPAREN> ( ID() ( <COMMA> ID() )* ) #PARAS <RPAREN> #FUN
		{
			SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // #FUN
			SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // #paras
			SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); // #dim
			SimpleNode midNode4 = (SimpleNode)jjtree.popNode();// #function name
			midNode4.jjtSetParent(midNode1);
			midNode3.jjtSetParent(midNode1);
			midNode2.jjtSetParent(midNode1);
			midNode1.jjtAddChild(midNode4, 0);
			midNode1.jjtAddChild(midNode3, 1);
			midNode1.jjtAddChild(midNode2, 2);
			jjtree.pushNode(midNode1);
		}
		]
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());

		Token t;
		do
		{
			t = getNextToken();
		}
		while(t.kind != SEMICOLON);
	}
}

void tagset() :{}
{
	
	   <ORDERED><FINITE><PERIODIC> "{" orderdedFinitePeriodicTagSet() "}"  |
	   
	   <ORDERED><FINITE><NONPERIODIC> "{"orderdedFiniteNonperiodicTagSet()"}"|
	   
       <ORDERED><INFINITE><PERIODIC> "{" orderedInfinitePeriodicTagSet()"}" |
       
       <ORDERED><INFINITE><NONPERIODIC> "{" orderedInfiniteNonperiodicTagSet()"}"|
       //<ORDERED><INFINITE><NONPERIODIC>"{"<MINUSINF><TO><PLUSINF>"}" #ORDEREDFINITENONPERIODICTAGSET_INFINITY|
       
       <UNORDERED><FINITE><PERIODIC> "{" unorderedFinitePeriodicTagSet()"}" |
       
       <UNORDERED><FINITE><NONPERIODIC> "{" unorderedFiniteNonperiodicTagSet()"}" |
       <UNORDERED><INFINITE><PERIODIC> "{" unorderedInfinitePeriodicTagSet()"}"
      //<UNORDERED><INFINITE><NONPERIODIC> "{" unorderedInfiniteNoneriodicTagSet()"}"
}


// ORDEREDFINITEPERIODICTAGSET
//     /               \
//   PERIOD          TIMES
void orderdedFinitePeriodicTagSet():{}
{
	("<"(E()(<COMMA>E())* ) #PERIOD">" <COLON> INTEGER()#TIMES) #ORDEREDFINITEPERIODICTAGSET
}

void orderdedFiniteNonperiodicTagSet():{}{
	 E()orderdedFiniteNonperiodicTagSet1()
}

void orderdedFiniteNonperiodicTagSet1():{}
{
	((<TO> E() [<STEP> E()])#ORDEREDFINITENONPERIODICTAGSET_LOWERUPPER
	|
	(<COMMA>E())* #ORDEREDFINITENONPERIODICTAGSET_ENUMERATED)
	
	{
		adjustPosition();
	}
}
/*
*It is the method to deal with moving the nodes
*/

JAVACODE void adjustPosition()
{
	    SimpleNode tailE=(SimpleNode)jjtree.popNode(); //this is {2,3}
		SimpleNode firstE =(SimpleNode)jjtree.popNode();// this is 1
		int length=tailE.children.length;
        SimpleNode lastE=(SimpleNode)tailE.children[length-1];		Vector tailECopy=new Vector(); //copy of all the tailE		for(int i=0; i<length; i++)		{			tailECopy.addElement(tailE.children[i]);		}				for(int i=0; i<length; i++)		{						SimpleNode tempNode=(SimpleNode)tailECopy.elementAt(i);			tailE.jjtAddChild(tempNode, i+1); //move the current Es in tailE to the next position in order to insert the firstE as the first child					}				tailE.jjtAddChild(firstE, 0);		jjtree.pushNode(tailE);
}

void orderedInfinitePeriodicTagSet():{}
{
	("<"(E()(<COMMA>E())*) #PERIOD">") #ORDEREDINFINITEPERIODICTAGSET
}

void orderedInfiniteNonperiodicTagSet():{}
{
	(E()<TO><PLUSINF>[<STEP> E()]) #ORDEREDINFINITENONPERIODICTAGSET_LOWER|
	(<MINUSINF><TO>orderedInfiniteNonperiodicTagSet1())
	//(<MINUSINF><TO> E() [<STEP> E()])#ORDEREDINFINITENONPERIODICTAGSET_UPPER
//	{//		adjustPosition();//	}
	
}
void orderedInfiniteNonperiodicTagSet1():{}
{
	(E() [<STEP> E()])#ORDEREDINFINITENONPERIODICTAGSET_UPPER|
	<PLUSINF> #ORDEREDINFINITENONPERIODICTAGSET_INFINITY
}

void unorderedFinitePeriodicTagSet():{}
{
	("<"(E()(<COMMA>E())* ) #PERIOD">" <COLON> INTEGER()#TIMES) #UNORDEREDFINITEPERIODICTAGSET
}

void unorderedFiniteNonperiodicTagSet():{}
{
	(E()(<COMMA>E())*) #UNORDEREDFINITENONPERIODICTAGSET
}
void unorderedInfinitePeriodicTagSet():{}
{
	("<"(E()(<COMMA>E())*) #PERIOD">") #UNORDEREDINFINITEPERIODICTAGSET
}

// Note: Because of the scope issue, we have to put #ID at this position so that jjtThis can work properly
void ID() #ID:
{ 
	Token oToken;
}
{
	oToken = <ID>      // for example, we cannot put #ID over here, or jjtThis will not refer to Node ID.
	{
		jjtThis.setImage(oToken.image);
	}
}

void INTEGER() #INTEGER:
{
	Token oToken;
}
{
	oToken = <INTEGER_LITERAL>
	{
		jjtThis.setType(0);
		jjtThis.setImage(oToken.image);
	}
}

void FLOAT() #FLOAT:
{
	Token oToken;
}
{
	oToken = <FLOATING_POINT_LITERAL>
	{
		jjtThis.setType(1);
		jjtThis.setImage(oToken.image);
	}
}


void STRING() #STRING:
{
	Token oToken;
}
{
	oToken = <STRING_LITERAL>
	{
		jjtThis.setType(2);
		jjtThis.setImage(oToken.image);
	}
}





// EOF
