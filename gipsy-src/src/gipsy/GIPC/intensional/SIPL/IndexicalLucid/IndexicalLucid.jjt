/*
 * $Id: IndexicalLucid.jjt,v 1.20 2005/09/15 03:09:57 mokhov Exp $
 *
 * This jjt file contains IndexicalLucid grammar, note: all IndexicalLucid
 * related node-creation are made to methods.
 */

/*
 * OPTIONS
 */

options 
{
	NODE_DEFAULT_VOID = true;
	LOOKAHEAD = 2;
	FORCE_LA_CHECK = true;
	STATIC = false;
}

/*
 * COMPILATION PART
 */

PARSER_BEGIN(IndexicalLucidParser)
package gipsy.GIPC.intensional.SIPL.IndexicalLucid;

import gipsy.GIPC.intensional.SimpleNode;
import gipsy.GIPC.util.Node;
import gipsy.GIPC.util.ParseException;
import gipsy.GIPC.util.SimpleCharStream;
import gipsy.GIPC.util.Token;
import gipsy.GIPC.util.TokenMgrError;
import gipsy.interfaces.AbstractSyntaxTree;
import marf.util.Debug;


/**
 * Does syntactic analysis, outputs an AST. Focuses on the Indexical Lucid.
 * Generated by JavaCC automatically.
 *
 * $Id: IndexicalLucid.jjt,v 1.20 2005/09/15 03:09:57 mokhov Exp $
 *
 * @author Chun Lei Ren
 * @author Serguei Mokhov
 * @version $Revision: 1.20 $
 * @see IndexicalLucidTreeConstants Provides the constants definition for an AST.
 * @see IndexicalLucidConstants     Provides the constants definition for parser.
 */
public class IndexicalLucidParser 
{
	/**
	 * Error count.
	 */
	private int iErrorCount = 0;

	/**
	 * Parses presumably an Indexical Lucid program and produces an AST
	 * @return abstract syntax tree if parse was successful; null otherwise.
	 */
	public AbstractSyntaxTree parse()
	{
		try
		{
			System.err.println("IndexicalLucid Parser Version $Revision: 1.20 $");
			SimpleNode oRoot = startParse(); /* the start state */
			System.err.println("Errors: " + this.iErrorCount);
			return new AbstractSyntaxTree(oRoot);
		}
		catch(ParseException e)
		{
			System.err.println(e);
			e.printStackTrace(System.err);
			return null;
		}
	}
	
	/**
	 * Retrieves number of parse errors.
	 * @return error count
	 * @since Serguei
	 */
	public int getErrorCount()
	{
		return this.iErrorCount;
	}

	public static SimpleNode hash(SimpleNode node1, SimpleNode node2)
	throws ParseException
	{
		node1.jjtSetParent(node2);
		node2.jjtAddChild(node1, 0);
		return node2;
	}

	public static SimpleNode addOp(SimpleNode node1, SimpleNode node2, SimpleNode node3)
	throws ParseException
	{
		node1.jjtSetParent(node2);
		node3.jjtSetParent(node2);
		node2.jjtAddChild(node3, 0);
		node2.jjtAddChild(node1, 1);
		
		return node2;
	}

	public static SimpleNode relOp(SimpleNode node1, SimpleNode node2, SimpleNode node3) // right, relop, left
	throws ParseException
	{
		node1.jjtSetParent(node2);
		node3.jjtSetParent(node2);
		node2.jjtAddChild(node3, 0);
		node2.jjtAddChild(node1, 1);
		
		return node2;
	}
	
	public static SimpleNode at(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4) // right2 ,1, at, left (node1-4)
	throws ParseException
	{
		node1.jjtSetParent(node3);
		node2.jjtSetParent(node3);
		node4.jjtSetParent(node3);
		node3.jjtAddChild(node4, 0);
		node3.jjtAddChild(node2, 1);
		node3.jjtAddChild(node1, 2);
		
		return node3;
	}
	
	public static SimpleNode where(SimpleNode node1, SimpleNode node2, SimpleNode node3) 
	throws ParseException
	{
		node3.jjtSetParent(node2);
		node2.jjtAddChild(node3, 0);
		
		if(node1.children != null)
		{
			int i = node1.children.length;
			SimpleNode interNode;

			for(int j = 0; j < i; j++)
			{
				interNode = (SimpleNode)node1.children[j];
				interNode.jjtSetParent(node2);
				node2.jjtAddChild(interNode, j+1);
			}
		}
		
		return node2;
	}
}
PARSER_END(IndexicalLucidParser)



/****************** TOKEN DECLARATION ********************/

SKIP : /* WHITE SPACE */
{
	  " "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
	  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
	| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
	  <DIMENSION: "dimension">
	| <ELSE: "else">
	| <END: "end">
	| <FI: "fi">
	| <IF: "if">
	| <THEN: "then">
	| <WHERE: "where">
}

TOKEN : /* OPERATORS */
{
	/* regular operations */

	  <ASSIGN: "=">
	| <GT:     ">">
	| <LT:     "<">
	| <EQ:     "==">
	| <LE:     "<=">
	| <GE:     ">=">
	| <NE:     "!=">
	| <OR:     "or">
	| <AND:    "and">
	| <NOT:    "not">
	| <BITAND: "&">
	| <BITOR:  "|">
	| <PLUS:   "+">
	| <MINUS:  "-">
	| <STAR:   "*">
	| <SLASH:  "/">
	| <REM:    "%">
	
	/* binop */

	| <ASA: "asa">
	| <FBY: "fby">
	| <UPON: "upon">
	| <WVR: "wvr"> 
	
	/* unop */

	| <FIRST: "first">
	| <NEXT: "next">
	| <PREV: "prev">
	| <ISEOD: "iseod">

	/* base */	

	| <AT: "@">
	| <WHEN: "#">
}

TOKEN : /* LITERALS */
{
 /* < CONST:
        <INTEGER_LITERAL>
      | <FLOATING_POINT_LITERAL>
  >
|*/
  <INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
| <#OCTAL_LITERAL: "0" (["0"-"7"])*>
| <FLOATING_POINT_LITERAL:
	    (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
	  | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
	  | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
	  | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| <CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
| <STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/*
 * NOTE: need to keep this one in sync with:
 *   GIPL.jjt, IndexicalLucid.jjt, and PreprocessorParser.jjt.
 *   JGIPL.jjt and JIndexicalLucid.jjt are generated.
 */
TOKEN : /* IDENTIFIERS */
{
	<ID: <LETTER> (<LETTER>|<DIGIT>)*>

	| <#LETTER:
		[
			"\u0024",
			"\u0041"-"\u005a",
			"\u005f",
			"\u0061"-"\u007a",
			"\u00c0"-"\u00d6",
			"\u00d8"-"\u00f6",
			"\u00f8"-"\u00ff",
			"\u0100"-"\u1fff",
			"\u3040"-"\u318f",
			"\u3300"-"\u337f",
			"\u3400"-"\u3d2d",
			"\u4e00"-"\u9fff",
			"\uf900"-"\ufaff"
		]
	  >

	| <#DIGIT:
		[
			"\u0030"-"\u0039",
			"\u0660"-"\u0669",
			"\u06f0"-"\u06f9",
			"\u0966"-"\u096f",
			"\u09e6"-"\u09ef",
			"\u0a66"-"\u0a6f",
			"\u0ae6"-"\u0aef",
			"\u0b66"-"\u0b6f",
			"\u0be7"-"\u0bef",
			"\u0c66"-"\u0c6f",
			"\u0ce6"-"\u0cef",
			"\u0d66"-"\u0d6f",
			"\u0e50"-"\u0e59",
			"\u0ed0"-"\u0ed9",
			"\u1040"-"\u1049"
		]
	  >
}  /* Suppose they are UNICODE */

TOKEN : /* SEPARATORS */
{
	  <LPAREN: "(">
	| <RPAREN: ")">
	| <LBRACKET: "[">
	| <RBRACKET: "]">
	| <SEMICOLON: ";">  /* Peter suggests omit ';'*/
	| <COMMA: ",">
	| <DOT: ".">
}
 
TOKEN :  /* ILLEGAL CHARACTERS */ 
{
	<ILLEGALCHAR: ["~", "%", "^", "`"]>
	/* { System.err.println("illegal char occur"); } */
}	/* in the future, use unicode to express all illegal chars */


/**************** COMMON TOKEN ACTION  ****************/

TOKEN_MGR_DECLS :
{
	int iCount = 0;
	
	void commonTokenAction(Token poToken)
	{
	      System.out.println(poToken.image);
	}
}



/******************* SYNTAX  ******************/

/**
 * Counts errors during parsing.
 */
JAVACODE void countErrors()
{
	this.iErrorCount++;
}

JAVACODE SimpleNode sign(SimpleNode node1, SimpleNode node2) 
{
	node1.jjtSetParent(node2);
	node2.jjtAddChild(node1, 0);
	return node2;
}

JAVACODE SimpleNode multOp(SimpleNode node1, SimpleNode node2, SimpleNode node3) 
{
	node1.jjtSetParent(node2);
	node3.jjtSetParent(node2);
	node2.jjtAddChild(node3, 0);
	node2.jjtAddChild(node1, 1);
	
	return node2;
}

JAVACODE SimpleNode function(SimpleNode node1, SimpleNode node2, SimpleNode node3) 
{
	node1.jjtSetParent(node3);
	node2.jjtSetParent(node3);
	node3.jjtAddChild(node2, 0);
	node3.jjtAddChild(node1, 1);
	
	return node3;
}

JAVACODE SimpleNode first(SimpleNode node1, SimpleNode node2, SimpleNode node3) // id, dim, first
{
	node1.jjtSetParent(node3);
	node2.jjtSetParent(node3);
	node3.jjtAddChild(node1, 0);
	node3.jjtAddChild(node2, 1);	

	return node3;
}

// node1:id, node2:dim, next
JAVACODE SimpleNode next(SimpleNode node1, SimpleNode node2, SimpleNode node3)
{
	node1.jjtSetParent(node3);
	node2.jjtSetParent(node3);
	node3.jjtAddChild(node1, 0);
	node3.jjtAddChild(node2, 1);	

	return node3;
}

// node1:id, node2:dim
JAVACODE SimpleNode prev(SimpleNode node1, SimpleNode node2, SimpleNode node3)
{
	node1.jjtSetParent(node3);
	node2.jjtSetParent(node3);
	node3.jjtAddChild(node1, 0);
	node3.jjtAddChild(node2, 1);	

	return node3;
}

// this is for sipl, gipl doesn't need this function
// node1-4: if, 1st, 2nd, 3rd paras
JAVACODE SimpleNode ifClause(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4)  
{
	node2.jjtSetParent(node1);
	node3.jjtSetParent(node1);
	node4.jjtSetParent(node1);
	node1.jjtAddChild(node2, 0);
	node1.jjtAddChild(node3, 1);
	node1.jjtAddChild(node4, 2);

	return node1;
}
		
// node1:id-right, node2:dim, node3:fby, node4:id-left		
JAVACODE SimpleNode fby(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4)
{
	node1.jjtSetParent(node3);
	node2.jjtSetParent(node3);
	node4.jjtSetParent(node3);
	node3.jjtAddChild(node4, 0);
	node3.jjtAddChild(node2, 1);	
	node3.jjtAddChild(node1, 2);

	return node3;
}

JAVACODE SimpleNode makeQlist(SimpleNode child, SimpleNode parent) 
{
	child.jjtSetParent(parent);

	if (parent.children!=null)
	    parent.jjtAddChild(child, parent.children.length);
	else 
	    parent.jjtAddChild(child, 0);

	return parent;
}

JAVACODE SimpleNode assign(SimpleNode node1, SimpleNode node2, SimpleNode node3)  // left, =, right
{
	node1.jjtSetParent(node2);
	node3.jjtSetParent(node2);
	node2.jjtAddChild(node1, 0);
	node2.jjtAddChild(node3, 1);

	return node2;
}

JAVACODE SimpleNode wvr(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4)  // node1:id-right, node2:dim, node4:id-left
{
	node1.jjtSetParent(node3);
	node2.jjtSetParent(node3);
	node4.jjtSetParent(node3);
	node3.jjtAddChild(node4, 0);
	node3.jjtAddChild(node2, 1);	
	node3.jjtAddChild(node1, 2);

	return node3;
}

JAVACODE SimpleNode asa(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4)  // node1:id-right, node2:dim, node4:id-left
{
	node1.jjtSetParent(node3);
	node2.jjtSetParent(node3);
	node4.jjtSetParent(node3);
	node3.jjtAddChild(node4, 0);
	node3.jjtAddChild(node2, 1);	
	node3.jjtAddChild(node1, 2);

	return node3;
}

JAVACODE SimpleNode upon(SimpleNode node1, SimpleNode node2, SimpleNode node3, SimpleNode node4)  // node1:id-right, node2:dim, node4:id-left
{
	node1.jjtSetParent(node3);
	node2.jjtSetParent(node3);
	node4.jjtSetParent(node3);
	node3.jjtAddChild(node4, 0);
	node3.jjtAddChild(node2, 1);	
	node3.jjtAddChild(node1, 2);

	return node3;
}


SimpleNode startParse() #START : {}
{
	try 
	{ 
		E() <EOF>
		{
			return jjtThis;
		}
	}
	catch(ParseException e) 
	{
		countErrors();
		System.err.println("Indexical Lucid Parser: " + e.toString()); 
	}
}

void E() : {}
{
	try
	{
		( <IF> E() <THEN> E() <ELSE> E() <FI> ) #IF E1() 
		
		|	( <WHEN> #HASH <DOT> E() ) 
			{
				SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
				SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // #
				SimpleNode node = hash(midNode1, midNode2);
				jjtree.pushNode(node);
			}
			E1()   
		
		| Term() E1()
		
		|	( ( <PLUS> #POSI | <MINUS> #NEGE ) Term() )
			{
				SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // E
				SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // sign
				SimpleNode node = sign(midNode1, midNode2);
				jjtree.pushNode(node);
			}
			E1()

		/*
		 * The below comment is special and should be
		 * used by grammar-grammar generators, such as JGIPL.sh
		 * to insert new productions. When replacing, it's probably
		 * a good idea to re-isert the special comment again if
		 * there planned to be some further processing
		 */
		//{EXTEND-E}
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println("Indexical Lucid Parser: " + e.toString()); 
	}
}

void E1() : {}
{
  try {

  [    (( "+" #ADD | "-" #MIN | "or" #OR ) Term() ) 

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // AddOp
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=addOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

      E1() 
  
    | (( "<" #LT | ">" #GT | ">=" #GE | "<=" #LE | "==" #EQ | "!=" #NE ) E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // relOp
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=addOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

      E1()
 
    | ( "@" #AT "." E() E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right1
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // right2
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // AT
	   SimpleNode midNode4=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=at(midNode1, midNode2, midNode3, midNode4);
	   jjtree.pushNode(node);
	 }

      E1()
  
    | ("where" #WHERE  Q() #Qlist "end" ) 

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right
     	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // where
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=where(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

      E1()

    | ( Tail() ) 

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // paras
       SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // dim
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // function name
	   SimpleNode node=function(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }

      E1()

    | ( ("fby" #FBY) ( "["  E() ("," E())* "]" ) #DIM "("  E() ")" 
	
      | ( "fby" #FBY ) "." E() E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // id-right
       SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // dim
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // fby
	   SimpleNode midNode4=(SimpleNode) jjtree.popNode(); // id-left
	   SimpleNode node=fby(midNode1, midNode2, midNode3, midNode4);
	   jjtree.pushNode(node);
	 }

	E1()
  
    | ( ("wvr" #WVR) ( "["  E() ("," E())* "]" ) #DIM "("  E() ")" 
	
      | ( "wvr" #WVR ) "." E() E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // id-right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // dim
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // wvr
	   SimpleNode midNode4=(SimpleNode) jjtree.popNode(); // id-left
	   SimpleNode node=wvr(midNode1, midNode2, midNode3, midNode4);
	   jjtree.pushNode(node);
	 }

	E1()

    | ( ("asa" #ASA) ( "["  E() ("," E())* "]" ) #DIM "("  E() ")" 
	
      | ( "asa" #ASA ) "." E() E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // id-right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // dim
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // asa
	   SimpleNode midNode4=(SimpleNode) jjtree.popNode(); // id-left
	   SimpleNode node=asa(midNode1, midNode2, midNode3, midNode4);
	   jjtree.pushNode(node);
	 }

	E1()

    | ( ("upon" #UPON) ( "["  E() ("," E())* "]" ) #DIM "("  E() ")" 
	
      | ( "upon" #UPON ) "." E() E() )

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // id-right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // dim
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // upon
	   SimpleNode midNode4=(SimpleNode) jjtree.popNode(); // id-left
	   SimpleNode node=upon(midNode1, midNode2, midNode3, midNode4);
	   jjtree.pushNode(node);
	 }

	E1()

	//{EXTEND-E1}
  ]
  
  }
  catch(ParseException e)
  {
    countErrors();
    System.out.println(e.toString());
  }

}

// This Tail and the QTail later are not to be considered so far
void Tail() : {}
{
	try
	{
		<LBRACKET> ( E() ( <COMMA> E() )* ) #DIM <RBRACKET> <LPAREN> ( E() ( <COMMA> E() )* ) #PARAS <RPAREN> #FUN
	}
	catch(ParseException e)
	{
	    countErrors();
	    System.err.println(e.toString());
	    e.printStackTrace(System.err);
	}
}

void Term() : {}
{
	factor() Term1()
}

void Term1() :
{ }
{
   [( ( "*" #TIMES | "/" #DIV | "%" #MOD | "and" #AND )  Term() ) 

	 { SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // right
   	   SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // multOp
	   SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // left
	   SimpleNode node=multOp(midNode1, midNode2, midNode3);
	   jjtree.pushNode(node);
	 }
			      
   Term1()  ]
}


void factor() : {}
{
	  ID()
	| INTEGER()
	| FLOAT()
	| <LPAREN> E() <RPAREN>
	| ( <NOT> <LPAREN> E() <RPAREN> ) #NOT
	| unary()
	//{EXTEND-FACTOR}
}

void unary() : {}
{
	  ( ( <FIRST> #FIRST ) ( <LBRACKET> E() ( <COMMA> E() )* <RBRACKET> ) #DIM <LPAREN> E() <RPAREN>
	
	| ( <FIRST> #FIRST ) <DOT> E() E() )
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // id
	    SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // dim
		SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); // first
		SimpleNode node = first(midNode1, midNode2, midNode3);
		jjtree.pushNode(node);
	}

	| ( ( <NEXT> #NEXT ) ( <LBRACKET> E() ( <COMMA> E() )* <RBRACKET> ) #DIM <LPAREN> E() <RPAREN>
	| ( <NEXT> #NEXT ) <DOT> E() E() )
	{
		SimpleNode midNode1=(SimpleNode) jjtree.popNode(); // id
		SimpleNode midNode2=(SimpleNode) jjtree.popNode(); // dim
		SimpleNode midNode3=(SimpleNode) jjtree.popNode(); // next
		SimpleNode node=next(midNode1, midNode2, midNode3);
		jjtree.pushNode(node);
	}

	| ( ( <PREV> #PREV ) ( <LBRACKET> E() ( <COMMA> E() )* <RBRACKET> ) #DIM <LPAREN> E() <RPAREN>
	| ( <PREV> #PREV ) <DOT> E() E() )
	{
		SimpleNode midNode1 = (SimpleNode)jjtree.popNode(); // id
		SimpleNode midNode2 = (SimpleNode)jjtree.popNode(); // dim
		SimpleNode midNode3 = (SimpleNode)jjtree.popNode(); // prev
		SimpleNode node = prev(midNode1, midNode2, midNode3);
		jjtree.pushNode(node);
	}

	// TODO:
	| ( <ISEOD> <LBRACKET> E() ( <COMMA> E() )* <RBRACKET> <LPAREN>  E() <RPAREN> ) #ISEOD

	// | "[" E() "]" ( "fby" | "wvr" | "asa" | "upon" ) #BINOP "[" E() ( "," E())* "]" "(" E() ")"
	// binary operators should move up to production E1, and original grammar should be changed 
	// a little, that is to eliminate the ( and ) around E.
}

void Q() : {}
{
	try
	{
		  ( ( <DIMENSION> ID() ( <COMMA> ID() )* <SEMICOLON> ) #DIMENSION ) ( Q() )*   
		| ( ( ID() [ QTail() ] <ASSIGN> E() <SEMICOLON> ) #ASSIGN ) ( ( Q() )* )
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());

		Token t;
		do
		{
			t = getNextToken();
		}
		while(t.kind != SEMICOLON);
	}
}


void QTail() : {}
{
	try
	{
		<LBRACKET> ( ID() ( <COMMA> ID() )* ) #DIM <RBRACKET> <LPAREN> ( ID() ( <COMMA> ID() )* ) #PARAS <RPAREN> #FUN
		{
			Node midNode1 = jjtree.popNode(); // paras
			Node midNode2 = jjtree.popNode(); // dim
			Node midNode3 = jjtree.popNode(); // function name
			midNode1.jjtSetParent(midNode3);
			midNode2.jjtSetParent(midNode3);
			midNode3.jjtAddChild(midNode2, 0);
			midNode3.jjtAddChild(midNode1, 1);
			jjtree.pushNode(midNode3);
		}
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());

		Token t;
		do
		{
			t = getNextToken();
		}
		while(t.kind != SEMICOLON);
	}
}

// Note: Because of the scope issue, we have to put #ID at this position so that jjtThis can work properly
void ID() #ID:
{ 
	Token oToken;
}
{
	oToken = <ID>      // for example, we cannot put #ID over here, or jjtThis will not refer to Node ID.
	{
		jjtThis.setImage(oToken.image);
	}
}

void INTEGER() #CONST:
{
	Token oToken;
}
{
	oToken = <INTEGER_LITERAL>
	{
		jjtThis.setType(0);
		jjtThis.setImage(oToken.image);
	}
}

void FLOAT() #CONST:
{
	Token oToken;
}
{
	oToken = <FLOATING_POINT_LITERAL>
	{
		jjtThis.setType(1);
		jjtThis.setImage(oToken.image);
	}
}

// EOF
