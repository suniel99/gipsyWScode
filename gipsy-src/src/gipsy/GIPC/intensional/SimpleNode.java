package gipsy.GIPC.intensional;


import gipsy.GIPC.GIPC;
import gipsy.GIPC.intensional.GIPL.GIPLParser;
import gipsy.GIPC.intensional.GIPL.GIPLParserTreeConstants;
import gipsy.GIPC.intensional.SIPL.ForensicLucid.ForensicLucidParserTreeConstants;
import gipsy.GIPC.intensional.SIPL.IndexicalLucid.IndexicalLucidParser;
import gipsy.GIPC.intensional.SIPL.IndexicalLucid.IndexicalLucidParserTreeConstants;
import gipsy.GIPC.intensional.SIPL.Lucx.LucxParser;
import gipsy.GIPC.intensional.SIPL.Lucx.LucxParserTreeConstants;
import gipsy.GIPC.util.Node;

// july 4th 2002, I add one more constructor and one more method (copyNode). Both are for SIPL.

/** Generated By:JJTree: Do not edit this line. SimpleNode.java */

public class SimpleNode implements Node
{
	// TODO: must not be public
  public Node parent;
  public Node[] children;
  public int id;
  //protected GIPLParser oGIPLParser;
  //protected IndexicalLucidParser sipl;
  //protected LucxParser lucx; 
  protected String image; // customized attribute record the image of id, if it was an id
  public int type;      // customized attribute record the type of const, if it was a const
  public int ID;//add for semantic
  protected String rank;//add for semantic

  public SimpleNode() {   // customized constructor

  }

  public SimpleNode(int i) {
	id = i;
  }
/*
  public SimpleNode(GIPLParser p, int i) {
	this(i);
	this.oGIPLParser = p;
  }

  public SimpleNode(IndexicalLucidParser p, int i) {
	this(i);
	sipl = p;
  }
  
  /**
   * Newly added constructor to introduce Lucx
   */
/*   public SimpleNode(LucxParser p, int i) {
		this(i);
		lucx = p;
	  }
*/
  
  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

	public String toString()
	{
		// customized

		// TODO: fix this awful kludge
		if(GIPC.siPrimaryParserType == GIPC.GIPL_PARSER)
		{
			if(image != null)
			{
				return GIPLParserTreeConstants.jjtNodeName[id] + " : " + image;
			}
			else
			{
				return GIPLParserTreeConstants.jjtNodeName[id];
			}
		}
		
		// Added to deal with Lucx nodes.
		if(GIPC.siPrimaryParserType == GIPC.LUCX_PARSER)
		{
			if(image != null)
			{
				return LucxParserTreeConstants.jjtNodeName[id] + " : " + image;
			}
			else
			{
				return LucxParserTreeConstants.jjtNodeName[id];
			}
		}
		
		// Added to deal with Forensic Lucid nodes.
		if(GIPC.siPrimaryParserType == GIPC.FORENSIC_LUCID_PARSER)
		{
			if(image != null)
			{
				return ForensicLucidParserTreeConstants.jjtNodeName[id] + " : " + image;
			}
			else
			{
				return ForensicLucidParserTreeConstants.jjtNodeName[id];
			}
		}
		
		// Indexical Lucid
		{
			if(image != null)
			{
				return IndexicalLucidParserTreeConstants.jjtNodeName[id] + " : " + image;
			}
			else
			{
				return IndexicalLucidParserTreeConstants.jjtNodeName[id];
			}
		}
	}

  public String toString(String prefix) { return prefix + this; }

  /** Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
		SimpleNode n = (SimpleNode)children[i];
		if (n != null) {
			n.dump(prefix + " ");
		}
      }
    }
   // if (image != null) System.out.println(" "+image); // customized
  }

    public void dump2(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
		SimpleNode n = (SimpleNode)children[i];
		if (n != null) {
			n.dump(prefix + " "+ n.image + " " + n.ID);
		}
      }
    }
   // if (image != null) System.out.println(" "+image); // customized
  }

  public int getId() {
    return id;
  }

  /**
   * Returns the string image of a token.
   */
  public String getImage()
  {
	  return this.image;
  }

  /**
   * Sets the string image of a token.
   */
  public void setImage(String s) { // customized method
	image=s;
  }

  public int getType()
  {
	  return this.type;
  }

  public void setType(int t) {  // customized method
	type=t;
  }

  public String getRank()
  {
	  return this.rank;
  }

  public void setRank(String pstrRank)
  {
	  this.rank = pstrRank;
  }


  public void copyNode(SimpleNode node) {  // customized method
	parent=node.parent;
	id=node.id;
	//this.oGIPLParser = node.oGIPLParser;
	image=node.image;
	type=node.type;

	if (node.children!=null) {
 	  int i=node.children.length;
	    children=new SimpleNode[i];
	  for (int j=0; j<i; j++)
	    children[j]=node.children[j];
	}

  }
  
  
}
