/*
 * GIPL.jjt - GIPL Grammar File.
 *
 * Updated:
 *		$Id: GIPL.jjt,v 1.22 2005/08/27 16:56:19 mokhov Exp $
 *
 * Authors: Chun Lei Ren
 *          Serguei Mokhov
 *
 * Use SimpleNode, set NODE_DEFAULT_VOID option to true, that is to say, just
 * choose specific non-terminal and terminal to generate the parse tree.
 *
 * STATIC is set to false so that multiple instances of the parser could
 * be possible.
 *
 * NOTE: please be careful when maintaining this, as a number of grammars
 * are generated off it. See for example JGIPL.sh or ObjectiveGIPL.sh
 * in the JLucid and ObjectiveLucid directories.
 */


/*
 * OPTIONS
 */

options
{
	NODE_DEFAULT_VOID = true;
	LOOKAHEAD = 5;
	FORCE_LA_CHECK = true;
	STATIC = false;
}


/*
 * COMPILATION PART
 */

PARSER_BEGIN(GIPLParser)
package gipsy.GIPC.intensional.GIPL;

import gipsy.GIPC.intensional.SimpleNode;
import gipsy.GIPC.util.Node;
import gipsy.GIPC.util.ParseException;
import gipsy.GIPC.util.SimpleCharStream;
import gipsy.GIPC.util.Token;
import gipsy.GIPC.util.TokenMgrError;
import gipsy.interfaces.AbstractSyntaxTree;


/**
 * Does syntactic anlysis, outputs an AST.
 * Generated by JavaCC automatically.
 *
 * $Id: GIPL.jjt,v 1.22 2005/08/27 16:56:19 mokhov Exp $
 *
 * @author Chun Lei Ren
 * @author Serguei Mokhov
 *
 * @see GIPLParserTreeConstants Provides the constants definition for an AST.
 * @see GIPLParserConstants     Provides the constants definition for parser.
 */
public class GIPLParser
{
	/**
	 * Error count.
	 */
	private int iErrorCount = 0;

	/**
	 * Retrieves number of parse erros.
	 * @return abstract syntax tree if parse was successful; null otherwise.
	 */
	public AbstractSyntaxTree parse()
	{
		try
		{
			// startParse() is the start state
			SimpleNode oRoot = startParse();
			System.err.println("GIPL Parser, $Revision: 1.22 $: " + this.iErrorCount + " errors.");
			return new AbstractSyntaxTree(oRoot);
		}
		catch(ParseException e)
		{
			System.err.println(e);
			e.printStackTrace(System.err);
			return null;
		}
	}

	/**
	 * Retrieves number of parse erros.
	 * @return error count
	 */
	public int getErrorCount()
	{
		return this.iErrorCount;
	}
}
PARSER_END(GIPLParser)



/*
 * TOKEN DECLARATION
 */

SKIP : /* WHITE SPACE */
{
	  " "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
	  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
	| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
	  <DIMENSION: "dimension">
	| <ELSE: "else">
	| <END: "end">
	| <FI: "fi">
	| <IF: "if">
	| <THEN: "then">
	| <WHERE: "where">
}

TOKEN : /* OPERATORS */
{
	// Standard operators

	  <ASSIGN: "=">
	| <GT:     ">">
	| <LT:     "<">
	| <EQ:     "==">
	| <LE:     "<=">
	| <GE:     ">=">
	| <NE:     "!=">
	| <BITOR:  "|">
	| <BITAND: "&">
	| <OR:     "or">
	| <AND:    "and">
	| <NOT:    "not">
	| <PLUS:   "+">
	| <MINUS:  "-">
	| <TIMES:  "*">
	| <DIV:    "/">
	| <MOD:    "%">
	| <DOT:    ".">

	// Intensional operators

	| <AT:     "@">
	| <HASH:   "#">
}

TOKEN : /* LITERALS */
{
  <CONST:
        <INTEGER_LITERAL>
      | <FLOATING_POINT_LITERAL>
  >
| <INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
  | <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
  | <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | <#OCTAL_LITERAL: "0" (["0"-"7"])* >

| <FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
  | <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >

| <CHARACTER_LITERAL:
	  "'"
	  (   (~["'","\\","\n","\r"])
	    | ("\\"
	        ( ["n","t","b","r","f","\\","'","\""]
	        | ["0"-"7"] ( ["0"-"7"] )?
	        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
	        )
	      )
	  )
	  "'"
  >
| <STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/*
 * NOTE: need to keep this one in sync with:
 *   GIPL.jjt, IndexicalLucid.jjt, and PreprocessorParser.jjt.
 *   JGIPL.jjt and JIndexicalLucid.jjt are generated.
 */
TOKEN : /* IDENTIFIERS */
{
	<ID: <LETTER> (<LETTER>|<DIGIT>)*>

	| <#LETTER:
		[
			"\u0024",
			"\u0041"-"\u005a",
			"\u005f",
			"\u0061"-"\u007a",
			"\u00c0"-"\u00d6",
			"\u00d8"-"\u00f6",
			"\u00f8"-"\u00ff",
			"\u0100"-"\u1fff",
			"\u3040"-"\u318f",
			"\u3300"-"\u337f",
			"\u3400"-"\u3d2d",
			"\u4e00"-"\u9fff",
			"\uf900"-"\ufaff"
		]
	  >

	| <#DIGIT:
		[
			"\u0030"-"\u0039",
			"\u0660"-"\u0669",
			"\u06f0"-"\u06f9",
			"\u0966"-"\u096f",
			"\u09e6"-"\u09ef",
			"\u0a66"-"\u0a6f",
			"\u0ae6"-"\u0aef",
			"\u0b66"-"\u0b6f",
			"\u0be7"-"\u0bef",
			"\u0c66"-"\u0c6f",
			"\u0ce6"-"\u0cef",
			"\u0d66"-"\u0d6f",
			"\u0e50"-"\u0e59",
			"\u0ed0"-"\u0ed9",
			"\u1040"-"\u1049"
		]
	  >
}  /* Suppose they are UNICODE */

TOKEN : /* SEPARATORS */
{
	  <LPAREN: "(">
	| <RPAREN: ")">
	| <LBRACKET: "[">
	| <RBRACKET: "]">

	// Peter suggests we remove the semicolon.
	| <SEMICOLON: ";">
	| <COMMA: ",">
}

TOKEN : /* ILLEGAL CHARACTERS */
{
	<ILLEGALCHAR: ["~", "%", "^", "`"]>
} /* in the future, use unicode to express all illegal chars */


/*
 * COMMON TOKEN ACTION
 */

TOKEN_MGR_DECLS:
{
	int iCount = 0;

	void commonTokenAction(Token poToken)
	{
		System.out.println(poToken.image);
	}
}


/*
 * SYNTAX
 */

/**
 * Count errors during parsing.
 */
JAVACODE void countErrors()
{
	this.iErrorCount++;
}

/**
 * We start parsing GIPL here.
 */
SimpleNode startParse() #START : {}
{
	try
	{
		E() <EOF>
		{
			return jjtThis;
		}
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());
	}
}

/**
 * E().
 */
void E() : {}
{
	try
	{
	    ( <IF> E() <THEN> E() <ELSE> E() <FI> ) #IF E1()

		// CLR: please clarify the AST structure and implication of this operation
	    | ( <HASH> <DOT> E() ) #HASH E1()

	    | term() E1()

	    | ( ( <PLUS> #POSI | <MINUS> #NEGE ) term() )
			{
				Node midNode1 = jjtree.popNode(); // Term
	     		Node midNode2 = jjtree.popNode(); // Sign
				midNode1.jjtSetParent(midNode2);
				midNode2.jjtAddChild(midNode1, 0);
				jjtree.pushNode(midNode2);
			}
			E1()

		/*
		 * The below comment is special and should be
		 * used by grammar-grammar generators, such as JGIPL.sh
		 * to insert new productions. When replacing, it's probably
		 * a good idea to re-isert the special comment again if
		 * there planned to be some further processing
		 */
		//{EXTEND-E}
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());
	}
}

/**
 * E1().
 */
void E1() : {}
{
	try
	{
		[
			( ( <PLUS> #ADD | <MINUS> #MIN | <OR> #OR ) term() )
			{
				Node midNode1 = jjtree.popNode(); // right
	     		Node oAddNode = jjtree.popNode(); // AddOp
				Node midNode3 = jjtree.popNode(); // left
				midNode1.jjtSetParent(oAddNode);
				midNode3.jjtSetParent(oAddNode);
				oAddNode.jjtAddChild(midNode3, 0);
				oAddNode.jjtAddChild(midNode1, 1);
				jjtree.pushNode(oAddNode);
			}
			E1()

			| ( ( <LT> #LT | <GT> #GT | <GE> #GE | <LE> #LE | <EQ> #EQ | <NE> #NE ) E() )
			{
				Node midNode1 = jjtree.popNode(); // right
				Node midNode2 = jjtree.popNode(); // RelOp
				Node midNode3 = jjtree.popNode(); // left
				midNode1.jjtSetParent(midNode2);
				midNode3.jjtSetParent(midNode2);
				midNode2.jjtAddChild(midNode3, 0);
				midNode2.jjtAddChild(midNode1, 1);
				jjtree.pushNode(midNode2);
			}
			E1()

			| ( <AT> #AT <DOT> E() E() )
			{
				Node midNode1 = jjtree.popNode(); // right1
				Node midNode2 = jjtree.popNode(); // right2
				Node midNode3 = jjtree.popNode(); // AT
				Node midNode4 = jjtree.popNode(); // left
				midNode1.jjtSetParent(midNode3);
				midNode2.jjtSetParent(midNode3);
				midNode4.jjtSetParent(midNode3);
				midNode3.jjtAddChild(midNode4, 0);
				midNode3.jjtAddChild(midNode2, 1);
				midNode3.jjtAddChild(midNode1, 2);
				jjtree.pushNode(midNode3);
			}
			E1()

			| ( <WHERE> #WHERE Q() <END> )
			{
				Node midNode1 = jjtree.popNode(); // right
				Node midNode2 = jjtree.popNode(); // WHERE
				Node midNode3 = jjtree.popNode(); // left
				midNode1.jjtSetParent(midNode2);
				midNode3.jjtSetParent(midNode2);
				midNode2.jjtAddChild(midNode3, 0);
				midNode2.jjtAddChild(midNode1, 1);
				jjtree.pushNode(midNode2);
			}
			E1()

			| Tail() E1()
			
			//{EXTEND-E1}
		]
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());
	}
}

/**
 * This Tail and the QTail later are not to be considered so far.
 */
void Tail() : {}
{
	try
	{
		<LBRACKET> E() ( <COMMA> E() )* <RBRACKET> <LPAREN> E() ( <COMMA> E() )* <RPAREN>
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());
	}
}

void term() : {}
{
	factor() [ multTerm() ]
}

void multTerm() : {}
{
	( ( <TIMES> #TIMES | <DIV> #DIV | <MOD> #MOD | <AND> #AND ) term() )
	{
		Node midNode1 = jjtree.popNode(); // right
		Node midNode2 = jjtree.popNode(); // MultOp
		Node midNode3 = jjtree.popNode(); // left
		midNode1.jjtSetParent(midNode2);
		midNode3.jjtSetParent(midNode2);
		midNode2.jjtAddChild(midNode3, 0);
		midNode2.jjtAddChild(midNode1, 1);
		jjtree.pushNode(midNode2);
	}
	multTerm()
}

void factor() : {}
{
	ID()
	| CONST()
	| <LPAREN> E() <RPAREN>
	| ( <NOT> <LPAREN> E() <RPAREN> ) #NOT
	//{EXTEND-FACTOR}
}

void Q() : {}
{
	try
	{
		// AST structure of this operation need to be clarified
		( <DIMENSION> ID() ( <COMMA> ID() )* <SEMICOLON> ( Q() )* ) #DIMENSION

//   | (ID()         <ASSIGN> E() <SEMICOLON>  (Q())* ) #ASSIGN
//   | (ID() QTail() <ASSIGN> E() <SEMICOLON>  (Q())* ) #ASSIGN

//		| ( ID() ( QTail() | {} ) <ASSIGN> E() <SEMICOLON> ( Q() )* ) #ASSIGN
		| ( ID() [ QTail() ] <ASSIGN> E() <SEMICOLON> ( Q() )* ) #ASSIGN
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());

		Token oToken;
		do
		{
			oToken = getNextToken();
		}
		while(oToken.kind != SEMICOLON);
	}
}

void QTail() : {}
{
	try
	{
		<LBRACKET> ID() ( <COMMA> ID() )* <RBRACKET> <LPAREN> ID() ( <COMMA> ID() )* <RPAREN>
	}
	catch(ParseException e)
	{
		countErrors();
		System.err.println(e.toString());

		// Skip until we find a semicolon
		Token oToken;

		do
		{
			oToken = getNextToken();
		}
		while(oToken.kind != SEMICOLON);
	}
}

/**
 * Note: Because of the scope issue, we have to put #ID at this
 * position so that jjtThis can work properly.
 */
void ID() #ID:
{
	Token oToken;
}
{
	// for example, we cannot put #ID over here, or jjtThis
	// will not refer to Node ID.
	oToken = <ID>
	{
		jjtThis.setImage(oToken.image);
	}
}

void CONST() #CONST:
{
	Token oToken;
}
{
	oToken = <CONST>
	{
		jjtThis.setImage(oToken.image);
	}
}

// EOF
