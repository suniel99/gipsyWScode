package gipsy.GIPC;
import gipsy.GIPC.intensional.SimpleNode;
import gipsy.GIPC.intensional.SIPL.IndexicalLucid.IndexicalLucidParserConstants;
import gipsy.GIPC.intensional.SIPL.IndexicalLucid.IndexicalLucidParserTreeConstants;
import gipsy.GIPC.intensional.SIPL.JOOIP.JOOIPCompiler;
import gipsy.storage.Dictionary;
import gipsy.storage.DictionaryItem;
import gipsy.storage.FunctionItem;

import java.util.Hashtable;
import java.util.Stack;
import java.util.Vector;


/**
 * <p>Does semantic analysis based on the constants given by parser.
 * Input is an abstract syntactic tree got from parser.
 * Output includes the tree with attributes and a dictionary for GEE.</p>
 *
 * @author Aihua Wu
 * @author Serguei Mokhov
 * 
 * @since June 1, 2002
 * @version $Id: SemanticAnalyzer.java,v 1.28 2013/08/25 02:59:29 mokhov Exp $
 */
public class SemanticAnalyzer
implements ISemanticAnalyzer, IndexicalLucidParserConstants, IndexicalLucidParserTreeConstants
{
	/**
	 * TODO: document
	 */
	private DictionaryItem item, current, previous;

	/**
	 * Dictionary of identifiers.
	 */
	private Dictionary oDictionary = new Dictionary();

	/**
	 * TODO: document
	 */
	private int iCount;

	/**
	 * Number of semantic errors found.
	 */
	private int iErrorCount = 0;

	/**
	 * Number of warnings produced.
	 */
	private int iWarningCount = 0;

	/**
	 * TODO: document
	 */
	private Stack<SimpleNode> oSemanticStack = new Stack<SimpleNode>();

	/**
	 * TODO: document
	 */
	private Stack<SimpleNode> oTempStack = new Stack<SimpleNode>();

	/**
	 * TODO: document
	 */
	private Stack<SimpleNode> oSecondStack = new Stack<SimpleNode>();

	//for check the type and rank of identifiers second time.

	/**
	 * TODO: document
	 */
	private String p_kind = "identifier";

	/**
	 * TODO: document
	 */
	private String p_name = "";

	/**
	 * TODO: document
	 */
	private SimpleNode p_entry;

	/**
	 * TODO: document
	 */
	private int p_type = 0;

	/**
	 * TODO: document
	 */
	private boolean again = false; //for check second time

	/**
	 * TODO: document
	 */
	private Hashtable<String, FunctionItem> FunTable = new Hashtable<String, FunctionItem>(); //for function elimination

	/**
	 * TODO: document
	 */
	private FunctionItem FunIP = new FunctionItem();

	/**
	 * TODO: document
	 */
	private int DN = 0, PN = 0; //for setting up function

	/**
	 * TODO: document, fix hardcoding
	 */
	private String Dim[] = new String[10];

	/**
	 * TODO: document, fix hardcoding
	 */
	private String Para[] = new String[10];

	/**
	 * TODO: document
	 */
	private Vector<SimpleNode> PL = new Vector<SimpleNode>();

	/**
	 * TODO: document
	 */
	private boolean HasFun = false;

	/**
	 * Class constructor.
	 */
	public SemanticAnalyzer()
	{
	}

	/**
	 * Gets the dictionary generated by semantic analyzer.
	 *
	 * @return Dictionary  the entry for the dictionary.
	 */
	public Dictionary getDictionary()
	{
		return this.oDictionary;
	}

	/**
	 * Builds the dictionary.
	 *
	 * @param address  start node of AST as the entry in the dictionary.
	 */
	public void setupDictionary(SimpleNode address)
	{
		SimpleNode as, temp;
		previous = null;
		iCount = 0;
		address.ID = iCount;		
		current = new DictionaryItem(iCount, "Start", "", 2, "", address, null, true);		
		//'start' node
		oDictionary.addElement(current);
		current.getHashtable().put(current.getName(), current);
		iCount++;
				
		
		as = (SimpleNode)address.children[0];

		if(as.children != null)
		{
			as.dump(" ");
			setFunction(as, 0); //first deal with the function
			
			if(HasFun)
			{
				eliminateFunction(as, 0);
				HasFun = false;
			}

			traverseTree(as); //set up the dictionary of identifier
			TS(as);
		}
		else
			System.err.println("There is no program should be complied!");

		int co = 0;

		while(co < oSemanticStack.size())
		{
			oSecondStack.addElement(oSemanticStack.elementAt(co));
			co++;
		}

		if(!oSemanticStack.empty())
			typeCheck();

		co = 0;

		while(co < oSecondStack.size())
		{
			oSemanticStack.addElement(oSecondStack.elementAt(co));
			co++;
		}

		if((again) && (!oSemanticStack.empty()))
		{
			System.out.println("Second Semantic Check.");
			typeCheck();
		}

		for(int k = 0; k < oDictionary.size(); k++)
		{
			item = (DictionaryItem)oDictionary.elementAt(k);

			System.out.println
			(
				item.getID()
				+ " __ "
				+ item.getName()
				+ " __ "
				+ item.getKind()
				+ " __ "
				+ item.getType()
				+ " __ "
				+ item.getRank()
				+ " __ "
				+ item.getEntry()
			);
		}
	}

	/**
	 * Function operation.
	 *
	 * Traverses the AST, encounters function node, gets the information and stores
	 * it into a functions list table.
	 *
	 * @param FunT  the entry used to be judge if it is a function node.
	 * @param Sfn
	 *
	 * @see #take(SimpleNode)
	 * @see #eliminateFunction(SimpleNode, int)
	 * @see #duplicate(SimpleNode, SimpleNode, int)
	 * @see #replace(SimpleNode, String[], Vector)
	 */
	public void setFunction(SimpleNode FunT, int Sfn)
	{
		SimpleNode ft1, ft2, ft3, ftp;

		//if(FunT.id == JJTWHERE) //where
		if(FunT.toString().trim().equals("WHERE"))
		{
			ftp = (SimpleNode)FunT.parent;

			for(int m = 1; m < FunT.children.length; m++)
			{
				ft1 = (SimpleNode)FunT.children[m];
				//if(ft1.id == JJTASSIGN) //equal
				if(ft1.toString().trim().equals("ASSIGN"))
				{
					//if(((SimpleNode)ft1.children[0]).id == JJTFUN)
					if(((SimpleNode)ft1.children[0]).toString().trim().equals("FUN"))
						//is a function
					{
						HasFun = true;
						ft2 = (SimpleNode)ft1.children[0];
						p_name = ft2.getImage();
						if(ft2.children != null)
						{
							ft3 = (SimpleNode)ft2.children[0];

							//if(ft3.id == JJTDIM) //is dimension
							if(ft3.toString().trim().equals("DIM"))
							{
								DN = ft3.children.length;
								for(int d1 = 0; d1 < DN; d1++)
									Dim[d1] = ((SimpleNode)ft3.children[d1]).getImage();
							}
							else
							{
								PN = ft3.children.length;
								for(int d2 = 0; d2 < PN; d2++)
									Para[d2] = ((SimpleNode)ft3.children[d2]).getImage();
							}
							
							if(ft2.children.length == 2)
							{
								ft3 = (SimpleNode)ft2.children[1];
								PN = ft3.children.length;

								for(int d3 = 0; d3 < PN; d3++)
									Para[d3] = ((SimpleNode)ft3.children[d3]).getImage();
							}
							
							p_entry = take((SimpleNode)ft1.children[1]);
						}
						else
							p_entry = (SimpleNode)ft1.children[1];

						FunIP = new FunctionItem(p_name, DN, PN, p_entry);
						FunTable.put(p_name, FunIP);

						//if((((SimpleNode)ft1.children[1]).id != JJTWHERE)
						if (!(((SimpleNode)ft1.children[1]).toString().trim().equals("WHERE"))
							&& (FunT.children.length == 2))
							FunT = (SimpleNode)FunT.children[0];
						else
						{
							ft1.id = IndexicalLucidParserTreeConstants.JJTFUN;
							ft1.setImage("");
							ft1.children = null;
							ft1.parent = FunT;
							FunT.children[m] = ft1;
						}
					}
					else
						setFunction(ft1, m);
				}
			}
		}
		else
		{
			for(int i = 0; i < FunT.children.length; i++)
			{
				ft1 = (SimpleNode)FunT.children[i];
				
				if(ft1.children != null)
					setFunction(ft1, i);
			}
		}
	}

	/**
	 * Gets the parameters or dimensions for a function.
	 *
	 * @param FunB  simplenode type and used to gather information about parameters or dimension.
	 * @return simplenode type
	 */
	public SimpleNode take(SimpleNode FunB)
	{
		if(FunB.children == null)
		{
			//if(FunB.id == JJTID) //is a identifier
			if(FunB.toString().substring(0,FunB.toString().indexOf(":")).trim().equals("ID"))
			{
				for(int fp = 0; fp < PN; fp++)
					if(FunB.getImage().equals(Para[fp]))
						FunB.setImage("~" + Integer.toString(fp));
			}
			else
				//if(FunB.id == JJTDIMENSION)
				if(FunB.toString().trim().equals("DIMENSION"))
				{
					for(int fd = 0; fd < DN; fd++)
						if(FunB.getImage().equals(Dim[fd]))
							FunB.setImage("#" + Integer.toString(fd));
				}
		}
		else
		{
			for(int f = 0; f < FunB.children.length; f++)
				take((SimpleNode)FunB.children[f]);
		}

		return FunB;
	}

	/**
	 * Replaces function by its definition.
	 * The output of AST is a simple tree without function node.
	 *
	 * @param begin  Entry SimpleNode of a function.
	 * @param Fcn    integer number of children.
	 */
	public void eliminateFunction(SimpleNode begin, int Fcn)
	{
		FunctionItem FT = new FunctionItem();
		SimpleNode Fp, Fp1, Fparent, Ftemp1, Ftemp2;
		int FDnum = 0, FPnum = 0;
		int p1 = 0, p2 = 0;
		boolean IS = true;

		Dim = new String[10];
		Para = new String[10];

		//if((begin.id == JJTFUN) && (begin.getImage() != "")) //is a function
		if((begin.toString().trim().equals("FUN")) && (begin.getImage() != "")) 
		{
			if(FunTable.containsKey(begin.getImage()))
			{
				Fparent = (SimpleNode)begin.parent;

				if(begin.children != null)
					//judge has children, dimension or parameters
				{
					if(begin.children.length == 2)
					{
						Ftemp1 = (SimpleNode)begin.children[0];
						Ftemp2 = (SimpleNode)begin.children[1];
						FDnum = Ftemp1.children.length;
						FPnum = Ftemp2.children.length;
						for(int f1 = 0; f1 < FDnum; f1++)
							Dim[f1] =
								((SimpleNode)Ftemp1.children[f1]).getImage();
						for(int f2 = 0; f2 < FPnum; f2++)
							//Para[f2]=((SimpleNode)Ftemp2.children[f2]).getImage();
							PL.addElement((SimpleNode)Ftemp2.children[f2]);
					}
					else
					{
						Ftemp1 = (SimpleNode)begin.children[0];
						if(Ftemp1.toString().trim().equals("DIM"))
						//if(Ftemp1.id == JJTDIM)
						{
							FDnum = Ftemp1.children.length;
							for(int f1 = 0; f1 < FDnum; f1++)
								Dim[f1] =
									((SimpleNode)Ftemp1.children[f1])
										.getImage();
						}
						else
							//if(Ftemp1.id == JJTPARAS)
							if(Ftemp1.toString().trim().equals("PARAS"))
							{
								FPnum = Ftemp1.children.length;
								for(int f2 = 0; f2 < FPnum; f2++)
									//Para[f2]=((SimpleNode)Ftemp1.children[f2]).getImage();
									PL.addElement(
										(SimpleNode)Ftemp1.children[f2]);
							}
					}
				}

				FT = (FunctionItem)FunTable.get(begin.getImage());
				Fp = FT.getFunctionEntry();

				if((FT.getDimensions() != FDnum)
					|| (FT.getParamCount() != FPnum))
				{
					System.err.println("Semantic error: Function parameters' number error.");
					iErrorCount++;
					return;
				}

				//duplicate a small tree
				Fp1 = new SimpleNode(Fp.id);
				Fp1.setImage(Fp.getImage());
				Fp1.parent = null;
				if(Fp.children != null)
					for(int dup = 0; dup < Fp.children.length; dup++)
						duplicate(Fp1, (SimpleNode)Fp.children[dup], dup);

				//replace the function real parameter
				System.out.println
				(
					PL.size()
						+ "*****"
						+ ((SimpleNode)PL.elementAt(0)).id
						+ "//"
						+ ((SimpleNode)PL.elementAt(1)).id
				);

				replace(Fp1, Dim, PL);

				//replace the function
				//if(Fp1.id != JJTWHERE)
				if(!(Fp1.toString().trim().equals("WHERE")))
				{ //isn't where
					Fp1.parent = begin.parent;
					((SimpleNode)begin.parent).children[Fcn] = Fp1;
				}
				else
				{
					((SimpleNode)Fp1.children[0]).parent = begin.parent;
					((SimpleNode)begin.parent).children[Fcn] =
						(SimpleNode)Fp1.children[0];

					while(IS)
					{
						//if((Fparent.id == JJTASSIGN)|| (Fparent.id == JJTWHERE))
						if((Fparent.toString().trim().equals("ASSIGN"))
							|| (Fparent.toString().equals("WHERE")))
							IS = false;
						else
							if(Fparent.parent == null)
							{
								System.err.println(
									"Semantic error: Error AST structure.");
								iErrorCount++;
								return;
							}
							else
								Fparent = (SimpleNode)Fparent.parent;
					}

					//if(Fparent.id == JJTASSIGN)
					if(Fparent.toString().trim().equals("ASSIGN"))
					{
						((SimpleNode)Fparent.children[1]).parent = Fp1;
						Fp1.children[0] = (SimpleNode)Fparent.children[1];

						Fp1.parent = Fparent;
						Fparent.children[1] = Fp1;
					}
					//if(Fparent.id == JJTWHERE)
					if(Fparent.toString().trim().equals("WHERE"))
					{
						p1 = Fparent.children.length;
						p2 = Fp1.children.length;
						for(int p3 = 1; p3 < p2; p3++)
						{
							((SimpleNode)Fp1.children[p3]).parent = Fparent;
							Fparent.jjtAddChild(
								(SimpleNode)Fp1.children[p3],
								p1 + p3 - 1);
						}
					}
				}
			}
			else
			{
				System.err.println("Semantic error: No such function.");
				iErrorCount++;
				return;
			}
		}
		else
		{
			if(begin.children != null)
				for(int r = 0; r < begin.children.length; r++)
				{
					Ftemp1 = (SimpleNode)begin.children[r];
					if(Ftemp1 != null)
						eliminateFunction(Ftemp1, r);
				}
		}
	}

	/**
	 * Duplicates a tree.
	 *
	 * @param poRoot Entry SimpleNode of the new tree.
	 * @param poOriginalTree  Entry SimpleNode of the old tree duplicated.
	 * @param piChildNo  integer type and the Child_Num-th child.
	 *
	 * TODO: move to AbstractSyntaxTree
	 */
	public static void duplicate
	(
		SimpleNode poRoot,
		SimpleNode poOriginalTree,
		int piChildNo
	)
	{
		SimpleNode oDupTree;

		oDupTree = new SimpleNode(poOriginalTree.id); //= node
		oDupTree.setImage(poOriginalTree.getImage());
		oDupTree.parent = poRoot;
		poRoot.jjtAddChild(oDupTree, piChildNo);

		if(poOriginalTree.children != null)
		{
			for(int r = 0; r < poOriginalTree.children.length; r++)
			{
				duplicate
				(
					(SimpleNode)poRoot.children[piChildNo],
					(SimpleNode)poOriginalTree.children[r],
					r
				);
			}
		}

	}

	/**
	 * Uses real dimensions and parameters of a function to replace the definition
	 * of a function.
	 *
	 * @param ReTree the entry SimpleNode be replaced
	 * @param dim[] dimensions String
	 * @param pl  parameters Vector
	 */
	public void replace(SimpleNode ReTree, String dim[], Vector<SimpleNode> pl)
	{
		SimpleNode Rep, temp_p;
		int loc = 0;

		if(ReTree.children == null)
		{
			//if((ReTree.id == JJTDIMENSION)
			if((ReTree.toString().trim().equals("DIMENSION"))
				&& (ReTree.getImage().charAt(0) == '#'))
			{
				loc = Integer.parseInt(ReTree.getImage().substring(1));
				ReTree.setImage(dim[loc]);
			}
			else
				//if((ReTree.id == JJTID)
				if((ReTree.toString().substring(0,ReTree.toString().indexOf(":")).trim().equals("ID"))
					&& (ReTree.getImage().charAt(0) == '~'))
				{
					loc = Integer.parseInt(ReTree.getImage().substring(1));
					//ReTree.getImage()=para[loc];
					temp_p = (SimpleNode)pl.elementAt(loc);
					temp_p.parent = ReTree.parent;
					ReTree.id = temp_p.id;
					ReTree.setImage(temp_p.getImage());
					ReTree.children = temp_p.children;
					ReTree.type = temp_p.type;
					ReTree.ID = temp_p.ID;
					ReTree.setRank(temp_p.getRank());
				}
		}
		else
		{
			for(int r = 0; r < ReTree.children.length; r++)
				replace((SimpleNode)ReTree.children[r], Dim, PL);
		}
	}

	/**
	 *  Set up dictionary.
	 *  Traverses a tree, analyzes the attributes of each identifier,
	 *  sets up the corresponding dictionary.
	 *
	 *  @param begin  entry SimpleNode of the tree will be traversed
	 *  @see SubTree1(SimpleNode tree1, DictionaryItem C_scope).
	 *  @see SubTree2(SimpleNode tree2, String N, int Num).
	 *  @see SubTree5(SimpleNode tree5, int Num5).
	 *  @see TS(SimpleNode T).
	 *  @see SubTree4(SimpleNode tree4, DictionaryItem current_scope).
	 *  @see int lookfor(String tree4).
	 *  @see boolean Conflict(String name).
	 */
	public void traverseTree(SimpleNode begin)
	{
		SimpleNode n, sub_begin, sub_node, temp_node, temp_node2;
		DictionaryItem p_item;
		int t, g_count, tt;
		boolean Con = true;
		boolean fin_in_dim=false;

		t = begin.children.length;				
		//if(begin.id == JJTWHERE) //where
		if (begin.toString().trim().equals("WHERE"))
		{
			n = (SimpleNode)begin.parent;			
			if(n.toString().trim().equals("ASSIGN"))
		    //if (n.id == JJTASSIGN)
				//if is '=', insert to sub_table of identifier
			{
				//System.out.println("I am here 9.2:"+n.toString());
				p_name = ((SimpleNode)n.children[0]).getImage();
				p_entry = (SimpleNode)begin.children[0];
				((SimpleNode)n.children[0]).ID = iCount;
				p_kind = "identifier";
				if(((SimpleNode)n.children[1]).children == null)
					p_type = ((SimpleNode)n.children[1]).type;
				else
					p_type = -1;

				p_item =
					new DictionaryItem
					(
						iCount,
						p_name,
						p_kind,
						p_type,
						"",
						p_entry,
						previous,
						false
					);
				//System.out.println("before write to dic"+p_item.toString());
				
				oDictionary.addElement(p_item);
				temp_node = (SimpleNode)n.parent;
				tt = temp_node.children.length;
				sub_begin = (SimpleNode)temp_node.children[0];
				SubTree2(sub_begin, p_name, iCount);
				//write the ID to the first child of where
				int tt1 = 1;

				while((Con) && (tt1 < tt))
				{
					temp_node2 = (SimpleNode)temp_node.children[tt1];
					if(temp_node2.toString().trim().equals("ASSIGN"))
					//if(temp_node2.id == JJTASSIGN)
					{
						if(((SimpleNode)temp_node2.children[0]).ID == iCount)
								Con = false;
						else
						{
							temp_node2 = (SimpleNode)temp_node2.children[1];
							SubTree5(temp_node2, iCount);
							tt1++;
						}
					}
					else
						tt1++;
				}

				iCount++;
				previous = current;
				current =
					new DictionaryItem
					(
						(iCount - 1),
						p_name,
						"",
						-1,
						"",
						null,
						previous,
						true
					);				
				current.getHashtable().put(current.getName(), current);
				sub_begin = (SimpleNode)begin.children[0];				
				SubTree1(sub_begin, current);
				g_count = 1;				
				n = (SimpleNode)begin.children[g_count];				
				while((n.toString().trim().equals("DIMENSION"))&&(!fin_in_dim))
				//while(n.id == JJTDIMENSION)
				{
					for(int gg = 0; gg < n.children.length; gg++)
					{
						sub_node = (SimpleNode)n.children[gg];						
						
						if(conflict(sub_node.getImage()))
						{
							System.err.println
							(
								" Semantic error: "
									+ sub_node.getImage()
									+ " conflict."
							);

							iErrorCount++;
						}

						p_kind = "dimension";
						p_name = sub_node.getImage();
						((SimpleNode)n.children[gg]).ID = iCount;

						p_item =
							new DictionaryItem
							(
								iCount,
								p_name,
								p_kind,
								2,
								"",
								null,
								null,
								false
							);

						current.getHashtable().put(sub_node.getImage(), p_item);
						oDictionary.addElement(p_item);
						iCount++;
					}

					g_count++;					
					if (g_count<begin.children.length) n = (SimpleNode)begin.children[g_count];
					else fin_in_dim=true;						
				}
				//current=current.previous;//delete the current scope
				
				if (g_count<begin.children.length)
				{	
				  for(int g = g_count; g < begin.children.length; g++)
				  {
					n = (SimpleNode)begin.children[g];
					if (n.toString().trim().equals("ASSIGN"))
					//if(n.id == JJTASSIGN)
					{ //equal
						//if(((SimpleNode)n.children[1]).id != JJTWHERE) //where
						if(!(((SimpleNode)n.children[1]).toString().trim().equals("WHERE")))
						{
							p_name = ((SimpleNode)n.children[0]).getImage();
							p_kind = "identifier";
							((SimpleNode)n.children[0]).ID = iCount;
							if(((SimpleNode)n.children[1]).children == null)
								p_type = ((SimpleNode)n.children[1]).type;
							else
								p_type = -1;
							p_entry = (SimpleNode)n.children[1];
							p_item =
								new DictionaryItem(
									iCount,
									p_name,
									p_kind,
									p_type,
									"",
									p_entry,
									previous,
									false);
							oDictionary.addElement(p_item);
							SubTree2(sub_begin, p_name, iCount);
							for(int gg2 = 1; gg2 < g; gg2++)
							{
								temp_node = (SimpleNode)begin.children[gg2];
								if(temp_node.toString().trim().equals("ASSIGN"))
								//if(temp_node.id == JJTASSIGN)
								{
									temp_node =
										(SimpleNode)temp_node.children[1];
									SubTree5(temp_node, iCount);
								}
							}
							iCount++;
							SubTree4((SimpleNode)n.children[1], current);
							//write the ID to the right tree;
						}
						if((!(n.toString().trim().equals("FUN"))) && (n.children != null))
						//if((n.id != JJTFUN) && (n.children != null))
							traverseTree(n);
						else
							if (!(n.toString().trim().equals("FUN")))
							{
								n.setRank(""); //the rank of Const;
								oSemanticStack.push(n); //push the leave
							}
					}
					else
						if (!(n.toString().trim().equals("FUN")))
							System.err.println("Semantic Analyzer: erroneous structure of the AST.");
				  }
			  }

				current = current.getPrevious(); //delete the current scope;
			}//finish if it is "assign"
			else //where under condition 1, no =
			{
				sub_begin = (SimpleNode)begin.children[0];
				
				SubTree1(sub_begin, current); //for 'where' under condition 1
				
				for(int m = 1; m < begin.children.length; m++)
				{
					n = (SimpleNode)begin.children[m];					
					if (n.toString().trim().equals("DIMENSION"))
					//if(n.id == JJTDIMENSION)
					{ //dimension
						for(int mm = 0; mm < n.children.length; mm++)
						{
							sub_node = (SimpleNode)n.children[mm];
							if(conflict(sub_node.getImage()))
							{
								System.err.println(
									" Semantic error: "
										+ sub_node.getImage()
										+ " conflict.");
								iErrorCount++;
							}
							p_kind = "dimension";
							p_name = sub_node.getImage();
							((SimpleNode)n.children[mm]).ID = iCount;
							p_item =
								new DictionaryItem(
									iCount,
									p_name,
									p_kind,
									2,
									"",
									null,
									null,
									false);
							current.getHashtable().put(
								sub_node.getImage(),
								p_item);
							oDictionary.addElement(p_item);
							iCount++;
						}
					}
					else
						if (n.toString().trim().equals("ASSIGN")) 
						//if(n.id == JJTASSIGN)
						{ //equal
							if(!(((SimpleNode)n.children[1]).toString().trim().equals("WHERE")))
								//where
							{
								p_name = ((SimpleNode)n.children[0]).getImage();
								p_kind = "identifier";
								p_entry = (SimpleNode)n.children[1];
								((SimpleNode)n.children[0]).ID = iCount;
								if(((SimpleNode)n.children[1]).children
									== null)
									p_type = ((SimpleNode)n.children[1]).type;
								else
									p_type = -1;
								p_item =
									new DictionaryItem(
										iCount,
										p_name,
										p_kind,
										p_type,
										"",
										p_entry,
										previous,
										false);
								oDictionary.addElement(p_item);
								SubTree2(sub_begin, p_name, iCount);
								for(int mm2 = 1; mm2 < m; mm2++)
								{
									temp_node = (SimpleNode)begin.children[mm2];
									if (temp_node.toString().trim().equals("ASSIGN"))
									//if(temp_node.id == JJTASSIGN)
									{
										temp_node =
											(SimpleNode)temp_node.children[1];
										SubTree5(temp_node, iCount);
									}
								}
								iCount++;
								SubTree4((SimpleNode)n.children[1], current);
								//write the ID to the right tree;
							}
							if((!(n.toString().trim().equals("FUN"))) && (n.children != null))
							//if((n.id != JJTFUN) && (n.children != null))												
								traverseTree(n);							
							else
								if(!(n.toString().trim().equals("FUN")))
								//if(n.id != JJTFUN)
								{
									n.setRank(""); //the rank of Const;
									oSemanticStack.push(n); //push the leave
								}
						}
						else
							if(!(n.toString().trim().equals("FUN")))
							//if(n.id != JJTFUN)
								System.err.println(
									"error structure of the Tree.");
				}
			 }
		}
		else//finish the first if it is "where"
		{
			for(int i = 0; i < t; i++)
			{
				n = (SimpleNode)begin.children[i];
				if((!(n.toString().trim().equals("FUN"))) && (n.children != null))
				//if((n.id != JJTFUN) && (n.children != null))
					traverseTree(n);				
				else
					//if(n.id != JJTFUN)
					if(!(n.toString().trim().equals("FUN")))
					{
						n.setRank(""); //the rank of Const;
						oSemanticStack.push(n); //push the leave
					}
			}
		}
	}

	/**
	 *  Writes the ID to the first child of where node, does semantic checking on scope.
	 *
	 *  If the identifier is defined, checks the scope, writes the ID to the left branch.
	 *  If the identifier is new, generates the ID for the identifier, writes information
	 *  to the dicotionary, writes the ID to the left branch.
	 *
	 *  @param tree1    entry SimpleNode of the left branch.
	 *  @param C_scope  the DictionaryItem type, used to do scope checking.
	 */
	public void SubTree1(SimpleNode tree1, DictionaryItem C_scope)
	{
		DictionaryItem T1_item, T2_item, P_scope;
		SimpleNode T1_node;
		boolean IsNew = true;

		if(tree1.children == null)
		{
			tree1.setRank(""); //the rank of Const;
			oSemanticStack.push(tree1);
			//push the leave of the first child of where
			if(tree1.toString().substring(0,tree1.toString().indexOf(":")).trim().equals("ID"))			
			//if(tree1.id == JJTID)
			{ //is a identifier
				
				T1_node = (SimpleNode)tree1.parent;
				//if((T1_node.id == 3)
				//	|| ((T1_node.id == 15) && (T1_node.children[1] == tree1)))
				if((T1_node.toString().equals("HASH"))
					|| ((T1_node.toString().equals("AT")) && (T1_node.children[1] == tree1)))
						tree1.ID = lookfor(tree1.getImage());					
				else
				{
					if((C_scope.getHashtable().containsKey(tree1.getImage()))
						|| (C_scope.getName().equals(tree1.getImage())))
					{
						IsNew = false;
						T2_item =
							(DictionaryItem)C_scope.getHashtable().get(
								tree1.getImage());
						tree1.ID = T2_item.getID();
					}
					else
					{
						P_scope = C_scope.getPrevious();
						while(P_scope != null)
						{
							if((P_scope
								.getHashtable()
								.containsKey(tree1.getImage()))
								|| (P_scope.getName().equals(tree1.getImage())))
							{
								IsNew = false;
								T2_item =
									(DictionaryItem)P_scope.getHashtable().get(
										tree1.getImage());
								tree1.ID = T2_item.getID();
								P_scope = null;
							}
							else
								P_scope = P_scope.getPrevious();
						}
					}
					if(IsNew)
					{
						T1_item =
							new DictionaryItem(
								-1,
								tree1.getImage(),
								"",
								-1,
								"",
								null,
								previous,
								false);
						//System.out.println("new item="+T1_item.toString());
						current.getHashtable().put(tree1.getImage(), T1_item);
					}
				}
			}
		}//if there is children for nodes
		else
		{
			for(int j = 0; j < tree1.children.length; j++)
				SubTree1(((SimpleNode)tree1.children[j]), C_scope);
		}

	}

	/**
	 *  Writes the ID to the first child of where node.
	 *
	 *  This condition happens when the right branch of eaquel node is a where node.
	 *  After getting the ID of new identifier definition, the ID should be written back
	 *  to the left branch of the same eaquel node. Makes sure that each identifier on
	 *  the tree to have ID number and to be accessed by dictionary.
	 *
	 *  @param tree2  entry SimpleNode of the left branch.
	 *  @param N      the identifier's name String which will be written ID.
	 *  @param Num    the ID Integer for the identifier.
	 */
	public void SubTree2(SimpleNode tree2, String N, int Num)
	{
		DictionaryItem t2_item;

		if(tree2.children == null)
		{

			//if(tree2.id == JJTID) //is a identifier
			if(tree2.toString().substring(0,tree2.toString().indexOf(":")).trim().equals("ID"))
			{
				if(tree2.getImage().equals(N))
				{
					if((tree2.ID != 0) && (tree2.ID != -1))
					{
						System.err.println(
							" Semantic warning: "
								+ tree2.getImage()
								+ " re-defined.");
						iWarningCount++;
					}
					tree2.ID = Num;
				}
				if(current.getHashtable().containsKey(N))
				{					
					t2_item = (DictionaryItem)current.getHashtable().remove(N);
					t2_item.setID(Num);
					current.getHashtable().put(N, t2_item);
				}
			}
		}
		else
		{
			for(int j = 0; j < tree2.children.length; j++)
				SubTree2(((SimpleNode)tree2.children[j]), N, Num);
		}

	}

	/**
	 *  Writes the ID to the right branch of eaquel node.
	 *
	 *  After getting the ID of new identifier definition, the ID should be written back
	 *  to the right branch of the eaquel node. Makes sure that each identifier on
	 *  the tree to have ID number and can be accessed by dictionary.
	 *
	 *  @param tree5  entry SimpleNode of the right branch.
	 *  @param Num5   the ID Integer for the identifier.
	 */
	public void SubTree5(SimpleNode tree5, int Num5)
	{
		// write the ID to the before child of the branch
		DictionaryItem t5_item;

		if(tree5.children == null)
		{
			//if(tree5.id == JJTID) //is a identifier
			if(tree5.toString().substring(0,tree5.toString().indexOf(":")).trim().equals("ID"))
				if(tree5.ID == -1)
					tree5.ID = Num5;
		}
		else
		{
			for(int j = 0; j < tree5.children.length; j++)
				SubTree5(((SimpleNode)tree5.children[j]), Num5);
		}

	}

	/**
	 *  Prints the identifier's ID and its name, for debugging.
	 *
	 *  @param T entry SimpleNode for a tree.
	 *  @author Paula
	 */
	public void TS(SimpleNode T)
	{

		if(T.children == null)
		{
			// by paula, assume it's for debuggging
			//            if(T.id==JJTID)
			//                System.out.println(T.ID+"//"+T.getImage());
		}
		else
		{
			for(int j = 0; j < T.children.length; j++)
				TS(((SimpleNode)T.children[j]));
		}
	}

	/**
	 *  Writes the ID to the right child of where node, does semantic checking on scope.
	 *
	 *  If the identifier is defined, checks the scope, writes the ID to the right branch.
	 *  If the identifier is new, generates the ID for the identifier, writes information
	 *  to the dicotionary, writes the ID to the right branch.
	 *
	 *  @param tree4          entry SimpleNode of the right branch.
	 *  @param current_scope  the DictionaryItem type, used to do scope checking.
	 */
	public void SubTree4(SimpleNode tree4, DictionaryItem current_scope)
	{
		DictionaryItem T4_item, parent_scope;
		SimpleNode T4_node;

		if(tree4.children == null)
		{

			//if(tree4.id == JJTID)
			if(tree4.toString().substring(0,tree4.toString().indexOf(":")).trim().equals("ID"))
			{ //is a identifier

				if((current_scope
					.getHashtable()
					.containsKey(tree4.getImage()))
					|| (current_scope.getName().equals(tree4.getImage())))
				{
					T4_item =
						(DictionaryItem)current_scope.getHashtable().get(
							tree4.getImage());
					tree4.ID = T4_item.getID();
				}
				else
				{
					parent_scope = current_scope.getPrevious();
					while(parent_scope != null)
					{
						if((parent_scope
							.getHashtable()
							.containsKey(tree4.getImage()))
							|| (parent_scope.getName().equals(tree4.getImage())))
						{
							T4_item =
								(DictionaryItem)parent_scope
									.getHashtable()
									.get(
									tree4.getImage());
							tree4.ID = T4_item.getID();
							parent_scope = null;
						}
						else
							parent_scope = parent_scope.getPrevious();
					}
				}
			}

		}
		else
		{
			for(int j = 0; j < tree4.children.length; j++)
				SubTree4(((SimpleNode)tree4.children[j]), current_scope);
		}
	}

	/**
	 *  Checks if the identifier is defined.
	 *
	 *  @param tree4  identifier String.
	 *  @return  the integer position for the identifier on the dictionary.
	 */
	public int lookfor(String tree4)
	{
		int t4, t5 = 0;
		DictionaryItem temp4;

		for(t4 = 0; t4 < oDictionary.size(); t4++)
		{
			temp4 = (DictionaryItem)oDictionary.elementAt(t4);

			if(temp4.getName().equals(tree4))
			{
				t5 = t4;
				t4 = oDictionary.size();
			}
		}

		return t5;
	}

	/**
	 *  Checks whether the identifier names are conflict.
	 *
	 *  @param name  identifier String.
	 *  @return <code>true</code> the identifier is already defined.
	 *          <code>false</code> the identifier is not defined yet.
	 */
	public boolean conflict(String name)
	{
		boolean conflict = true;
		boolean warning = false;
		DictionaryItem parents;

		//if(current.ht.containsKey(name)) conflict=true;

		if(!current.getHashtable().containsKey(name))
			conflict = false;
		//if(current.name.equals(name)) conflict=true;

		parents = current.getPrevious();
		if((!conflict) && (parents != null))
		{
			while(parents != null)
			{
				if(parents.getHashtable().containsKey(name))
					warning = true;

				if(parents.getName().equals(name))
					warning = true;

				parents = parents.getPrevious();
			}

			if(warning)
			{
				System.out.println(" Semantic Warning: " + name + " overridding.");
				iWarningCount++;
			}
		}

		return conflict;
	}

	/**
	 *  Type checking and rank analysis.
	 *  The core part of semantic analysis.
	 *
	 *  @see Check(SimpleNode bRight, SimpleNode Result).
	 */
	public void typeCheck()
	{
		SimpleNode Right, Result;
		boolean judge = false;

		while(!oSemanticStack.empty())
		{
			Right = (SimpleNode)oSemanticStack.pop(); //the rightest leaf
			Result = (SimpleNode)Right.parent;
			//System.out.println("type checking 0: Right="+Right.toString()+"parent="+Result.toString());
			judge = check(Right, Result);			

			while(!judge)
			{
				Right = (SimpleNode)oSemanticStack.pop(); //the rightest leaf
				Result = (SimpleNode)Right.parent;
				//System.out.println("type checking 1: Right="+Right.toString()+"parent="+Result.toString());
				judge = check(Right, Result);
			}
		}
	}

	/**
	 *  Traverses the tree, gets the result of the checking.
	 *
	 *  @param bRight bRight children SimpleNode
	 *  @param Result Parent SimpleNode
	 *  @return <code>true</code> result obeys rules.
	 *          <code>false</code> result abused rules.
	 */
	public boolean check(SimpleNode Right, SimpleNode Result)
	{
		SimpleNode Left, temp_node;
		boolean found = false, finish = false;
		DictionaryItem temp = new DictionaryItem();
		DictionaryItem temp2 = new DictionaryItem();
		String R_str, L_str, T_str = "";
		int iTemp = 0;
		
		JOOIPCompiler oJooip = new JOOIPCompiler();
		

		//if((Result.id == JJTWHERE) || (Result.id == JJTDIMENSION)) //parent is dimension or where
		if((Result.toString().trim().equals("WHERE")) || (Result.toString().trim().equals("DIMENSION")))
		{
			finish = true;
			Right = (SimpleNode)Result.children[0];
			temp_node = (SimpleNode)Result.parent;
			if((Result.toString().trim().equals("WHERE"))&&(temp_node.toString().trim().equals("AT")))
			{				
				if (!(Right.toString().indexOf(":")==-1))
				{
					if (Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID"))
					{
						if (!oJooip.bIsJooip)
						{
							System.err.println(
									" Semantic error: Identifier "
									+ Right.getImage()
									+ " is not defined.");
							iErrorCount++;
						}else
						{
							iTemp = oDictionary.size();						
							temp2 = new DictionaryItem(iTemp,Right.getImage().concat("_JAVA_Defined"),"identifier_FLAG"+Right.getImage(),Right.type,"",null,null,false);
							oDictionary.addElement(temp2);
						}
					}
				}
			}
		}
		else
			//if(Result.id == JJTHASH) //parent is #
			if(Result.toString().trim().equals("HASH"))
			{
				Result.type = 0; //is integer
				int i = 1;
			  if (iCount==1)
			  {
				  found=false;
				  again=false;				  
			  }
			  else	
			  {
				while(i < iCount)
				{
					temp = (DictionaryItem)oDictionary.elementAt(i);
					if(temp.getName().equals(Right.getImage()))
					{
						if((!temp.getKind().equals("dimension")) && (!again))
						{
							System.out.println(" Semantic error: " + temp.getName() + " is not a dimension.");
							iErrorCount++;
						}
						else
						{
							Right.ID = temp.getID();
							i = iCount + 1;
							found = true;
						}
					}
					else
						i++;
				}
			  }

				if((!found) && (!again)) //? how to deal with it better?
				{
					//Result.setRank(bRight.getImage()+",";//for rank of #.d;
					Result.setRank(Right.ID + ",");
					System.err.println(
						" Semantic error: Dimension "
							+ Right.getImage()
							+ " is not defined.");
					iErrorCount++;
					Right = Result;
					Result = (SimpleNode)Right.parent;
					finish = check(Right, Result);
				}

				if(found)
				{
					//Result.setRank(bRight.getImage()+",";//for rank of #.d;
					Result.setRank(Right.ID + ",");
					Right = Result;
					Result = (SimpleNode)Right.parent;
					finish = check(Right, Result);
				}
			}//finish if result is hash

			else
				//if(((Result.id <= JJTMIN) && (Result.id >= JJTADD)) || ((Result.id <= JJTMOD) && (Result.id >= JJTTIMES))) //+,-,*,/,mod
				if((Result.toString().trim().equals("MIN"))||(Result.toString().trim().equals("ADD"))||
						(Result.toString().trim().equals("MOD"))||(Result.toString().trim().equals("TIMES"))
						||(Result.toString().trim().equals("DIV")))
				{
					if((SimpleNode)Result.children[0] == Right) //condition x+......
					{
						while(!oTempStack.empty())
						{
							Left = Right;
							Right = (SimpleNode)oTempStack.pop();
							Result = (SimpleNode)Left.parent;
							
							//if((Left.id == JJTID)
							if (!(Left.toString().indexOf(":")==-1))
							{
							if((Left.toString().substring(0,Left.toString().indexOf(":")).trim().equals("ID"))
								&& (Left.ID < oDictionary.size())
								&& (Left.ID > 0))
							{
								temp =
									(DictionaryItem)oDictionary.elementAt(
										Left.ID);
								if (temp.getType()==null) Left.type=-1;
								else Left.type = temp.getTypeEnumeration();
								if(temp.getRank() == null)
									Left.setRank("");
								else
									Left.setRank(temp.getRank());
							}
							else
								//if((Left.id == JJTID) && (!again))
								if((Left.toString().substring(0,Left.toString().indexOf(":")).trim().equals("ID")) && (!again))
								{
									if (!oJooip.bIsJooip)
									{
										System.err.println(
												" Semantic error: Identifier "
												+ Left.getImage()
												+ " is not defined.");
										iErrorCount++;
									}else
									{
										iTemp = oDictionary.size();	
										if (Left.parent.toString().trim().equals("ADD")) T_str = Left.getImage()+" + "+Right.getImage(); 
										else if (Left.parent.toString().trim().equals("MIN")) T_str=Left.getImage()+" - "+Right.getImage();
										else if (Left.parent.toString().trim().equals("WHERE")) T_str=Left.getImage();
										temp2 = new DictionaryItem(iTemp,Left.getImage().concat("_JAVA_Defined"),"identifier_FLAG"+T_str,Left.type,"",null,null,false);
										oDictionary.addElement(temp2);
									}
								}
							}
							
							if (!(Right.toString().indexOf(":")==-1))
							{
							//if((Right.id == JJTID)
							if((Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID"))
								&& (Right.ID < oDictionary.size())
								&& (Right.ID > 0))
							{
								temp =
									(DictionaryItem)oDictionary.elementAt(
										Right.ID);
								if (temp.getType()==null) Right.type=-1;
								else Right.type = temp.getTypeEnumeration();
								if(temp.getRank() == null)
									Right.setRank("");
								else
									Right.setRank(temp.getRank());
							}
							else
								//if((Right.id == JJTID) && (!again))
								if((Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID")) && (!again))
								{
									if (!oJooip.bIsJooip)
									{
										System.err.println(
												" Semantic error: Identifier "
												+ Right.getImage()
												+ " is not defined.");
										iErrorCount++;
									}
									else
									{
										iTemp = oDictionary.size();
										if (Left.parent.toString().trim().equals("ADD")) T_str = Left.getImage()+" + "+Right.getImage(); 
										else if (Left.parent.toString().trim().equals("MIN")) T_str=Left.getImage()+" - "+Right.getImage();
										else if (Left.parent.toString().trim().equals("WHERE")) T_str=Right.getImage();
										temp2 = new DictionaryItem(iTemp,Right.getImage().concat("_JAVA_Defined"),"identifier_FLAG"+T_str,Right.type,"",null,null,false);
										oDictionary.addElement(temp2);
									}
									
								}
							}

							//if(Result.id == JJTMOD)
							if(Result.toString().trim().equals("MOD"))
							{
								Result.type = 0;
								if((!again)
									&& ((Right.type != 0) || (Left.type != 0)))
								{
									System.err.println(
										" Semantic error: MOD operand: "
											+ Right.getImage()
											+ " and "
											+ Left.getImage()
											+ " must be integer.");
									iErrorCount++;
								}
							}
							else
							{
								if((Left.type == -1) && (Right.type == -1))
								{
									again = true;
									Result.type = -1;
								}
								else
									if(Left.type == -1)
									{
										again = true;
										Result.type = Right.type;
									}
									else
										if(Right.type == -1)
										{
											again = true;
											Result.type = Left.type;
										}
										else
										{
											if(Left.type == 2)
												Result.type = Right.type;
											else
											{
												if(Left.type == Right.type)
													//think about the type is -1?
												{
													Result.type = Right.type;
												}
												else
												{
													Result.type = 1;
													//if left!=right, then result is float;
												}
											}
										}
							}

							Result.setRank(Right.getRank() + Left.getRank());
							if(Result.getRank() != "")
								Result.setRank(Op_Str(Result.getRank()));

							Right = Result;
						}
						//if(((SimpleNode)Result.parent).id == JJTASSIGN)
						if(((SimpleNode)Result.parent).toString().trim().equals("ASSIGN"))
							finish = true; //parent is "=",then finish;
						else //parent is logical symbol, if, at, push the result into temp stack;
							{
							temp_node = (SimpleNode)Result.parent;
							if((SimpleNode)temp_node.children[0] == Result)
								finish = check(Result, temp_node);
							else
								oTempStack.push(Result);
						}
					}

					else
						if(((SimpleNode)Result.children[0]).children == null)
							//condition: x+a*b or a+b+c ;
						{
							oSemanticStack.pop();
							Left = (SimpleNode)Result.children[0];
							//the left child

							if (!(Left.toString().indexOf(":")==-1))
							{
							//if((Left.id == JJTID)
							if((Left.toString().substring(0,Left.toString().indexOf(":")).trim().equals("ID"))
								&& (Left.ID < oDictionary.size())
								&& (Left.ID > 0))
							{
								temp =
									(DictionaryItem)oDictionary.elementAt(
										Left.ID);
								if (temp.getType()==null) Left.type=-1;
								else Left.type = temp.getTypeEnumeration();
								
								if(temp.getRank() == null)
									Left.setRank("");
								else
									Left.setRank(temp.getRank());
							}
							else
								//if((Left.id == JJTID) && (!again))
								if((Left.toString().substring(0,Left.toString().indexOf(":")).trim().equals("ID")) && (!again))
								{
									if (!oJooip.bIsJooip)
									{
										System.err.println(
												" Semantic error: Identifier "
												+ Left.getImage()
												+ " is not defined.");
										iErrorCount++;
									}else
									{
										iTemp = oDictionary.size();
										if (Left.parent.toString().trim().equals("ADD")) T_str = Left.getImage()+" + "+Right.getImage(); 
										else if (Left.parent.toString().trim().equals("MIN")) T_str=Left.getImage()+" - "+Right.getImage();
										else if (Left.parent.toString().trim().equals("WHERE")) T_str=Left.getImage();
										temp2 = new DictionaryItem(iTemp,Left.getImage().concat("_JAVA_Defined"),"identifier_FLAG"+T_str,Left.type,"",null,null,false);
										oDictionary.addElement(temp2);
										
									}
								}
							}
							if (!(Right.toString().indexOf(":")==-1))
							{
							//if((Right.id == JJTID)
							if((Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID"))
								&& (Right.ID < oDictionary.size())
								&& (Right.ID > 0))
							{
								temp =
									(DictionaryItem)oDictionary.elementAt(
										Right.ID);
								if (temp.getType()==null) Right.type=-1;
								else Right.type = temp.getTypeEnumeration();
								if(temp.getRank() == null)
									Right.setRank("");
								else
									Right.setRank(temp.getRank());
							}
							else
								//if((Right.id == JJTID) && (!again))
								if((Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID")) && (!again))
								{
									if (!oJooip.bIsJooip)
									{
										System.err.println(
												" Semantic error: Identifier "
												+ Right.getImage()
												+ " is not defined.");
										iErrorCount++;
									}else
									{
										iTemp = oDictionary.size();
										if (Left.parent.toString().trim().equals("ADD")) T_str = Left.getImage()+" + "+Right.getImage(); 
										else if (Left.parent.toString().trim().equals("MIN")) T_str=Left.getImage()+" - "+Right.getImage();
										else if (Left.parent.toString().trim().equals("WHERE")) T_str=Right.getImage();
										temp2 = new DictionaryItem(iTemp,Right.getImage().concat("_JAVA_Defined"),"identifier_FLAG"+T_str,Right.type,"",null,null,false);
										oDictionary.addElement(temp2);
									}
								}
							}

							//if(Result.id == JJTMOD)
							if(Result.toString().trim().equals("MOD"))
							{
								Result.type = 0;
								if((!again)
									&& ((Right.type != 0) || (Left.type != 0)))
								{
									System.err.println(
										" Semantic error: MOD operand: "
											+ Right.getImage()
											+ " and "
											+ Left.getImage()
											+ " must be integer.");
									iErrorCount++;
								}
							}
							else
							{
								if((Left.type == -1) && (Right.type == -1))
								{
									again = true;
									Result.type = -1;
								}
								else
									if(Left.type == -1)
									{
										again = true;
										Result.type = Right.type;
									}
									else
										if(Right.type == -1)
										{
											again = true;
											Result.type = Left.type;
										}
										else
										{
											if(Left.type == 2)
												Result.type = Right.type;
											else
											{
												if(Left.type == Right.type)
													//think about the type is -1?
												{
													Result.type = Right.type;
												}
												else
												{
													Result.type = 1;
													//if left!=right, then result is float;
												}
											}
										}
							}

							Result.setRank(Right.getRank() + Left.getRank());
							if(Result.getRank() != "")
								Result.setRank(Op_Str(Result.getRank()));

							//if(((SimpleNode)Result.parent).id == JJTWHERE)
							if(((SimpleNode)Result.parent).toString().trim().equals("WHERE"))
									finish = true; //the expression before while
							else
							{
								if((((SimpleNode)Result.parent).children[0])
									== Result)
								{
									while(!oTempStack.empty())
									{
										Left = Result;
										Right = (SimpleNode)oTempStack.pop();
										Result = (SimpleNode)Left.parent;
										if (!(Left.toString().indexOf(":")==-1))
										{
										//if((Left.id == JJTID)
										if((Left.toString().substring(0,Left.toString().indexOf(":")).trim().equals("ID"))
											&& (Left.ID < oDictionary.size())
											&& (Left.ID > 0))
										{
											temp =
												(
													DictionaryItem)oDictionary
														.elementAt(
													Left.ID);
											if (temp.getType()==null) Left.type=-1;
											else Left.type = temp.getTypeEnumeration();
											if(temp.getRank() == null)
												Left.setRank("");
											else
												Left.setRank(temp.getRank());
										}
										else
											//if((Left.id == JJTID) && (!again))
											if((Left.toString().substring(0,Left.toString().indexOf(":")).trim().equals("ID")) && (!again))
											{
												if (!oJooip.bIsJooip)
												{
													System.err.println(
															" Semantic error: Identifier "
															+ Left.getImage()
															+ " is not defined.");
													iErrorCount++;
												}else
												{
													iTemp = oDictionary.size();
													if (Left.parent.toString().trim().equals("ADD")) T_str = Left.getImage()+" + "+Right.getImage(); 
													else if (Left.parent.toString().trim().equals("MIN")) T_str=Left.getImage()+" - "+Right.getImage();
													else if (Left.parent.toString().trim().equals("WHERE")) T_str=Left.getImage();
													temp2 = new DictionaryItem(iTemp,Left.getImage().concat("_JAVA_Defined"),"identifier_FLAG"+T_str,Left.type,"",null,null,false);
													oDictionary.addElement(temp2);
												}
											}
										}

										if (!(Right.toString().indexOf(":")==-1))
										{
										//if((Right.id == JJTID)
										if((Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID"))
											&& (Right.ID < oDictionary.size())
											&& (Right.ID > 0))
										{
											temp =
												(
													DictionaryItem)oDictionary
														.elementAt(
													Right.ID);
											if (temp.getType()==null) Right.type=-1;
											else Right.type = temp.getTypeEnumeration();
											if(temp.getRank() == null)
												Right.setRank("");
											else
												Right.setRank(temp.getRank());
										}
										else
											//if((Right.id == JJTID)
											if((Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID"))
												&& (!again))
											{
												if (!oJooip.bIsJooip)
												{
													System.err.println(
															" Semantic error: Identifier "
															+ Right.getImage()
															+ " is not defined.");
													iErrorCount++;
												}else
												{
													iTemp = oDictionary.size();
													if (Left.parent.toString().trim().equals("ADD")) T_str = Left.getImage()+" + "+Right.getImage(); 
													else if (Left.parent.toString().trim().equals("MIN")) T_str=Left.getImage()+" - "+Right.getImage();
													else if (Left.parent.toString().trim().equals("WHERE")) T_str=Right.getImage();
													temp2 = new DictionaryItem(iTemp,Right.getImage().concat("_JAVA_Defined"),"identifier_FLAG"+T_str,Right.type,"",null,null,false);
													oDictionary.addElement(temp2);
												}
											}
										}

										//if(Result.id == JJTMOD)
										if(Result.toString().trim().equals("MOD"))
										{
											Result.type = 0;
											if((!again)
												&& ((Right.type != 0)
													|| (Left.type != 0)))
											{
												System.err.println(
													" Semantic error: MOD operand: "
														+ Right.getImage()
														+ " and "
														+ Left.getImage()
														+ " must be integer.");
												iErrorCount++;
											}
										}
										else
										{
											if((Left.type == -1)
												&& (Right.type == -1))
											{
												again = true;
												Result.type = -1;
											}
											else
												if(Left.type == -1)
												{
													again = true;
													Result.type = Right.type;
												}
												else
													if(Right.type == -1)
													{
														again = true;
														Result.type = Left.type;
													}
													else
													{
														if(Left.type == 2)
															Result.type =
																Right.type;
														else
														{
															if(Left.type
																== Right.type)
																//think about the type is -1?
															{
																Result.type =
																	Right.type;
															}
															else
															{
																Result.type = 1;
																//if left!=right, then result is float;
															}
														}
													}
										}

										Result.setRank(
											Right.getRank() + Left.getRank());
										if(Result.getRank() != "")
											Result.setRank(
												Op_Str(Result.getRank()));
										//for rank[ A + - * / mod B ];
									}

									//if(((SimpleNode)Result.parent).id	== JJTASSIGN)
									if(((SimpleNode)Result.parent).toString().trim().equals("ASSIGN"))
										finish = true;
									//parent is "=",then finish;
									else //parent is logical symbol, if, at, push the result into temp stack;
										{
										temp_node = (SimpleNode)Result.parent;
										if((SimpleNode)temp_node.children[0]
											== Result)
											finish = check(Result, temp_node);
										else
											oTempStack.push(Result);
									}
								}
								else
								{
									oTempStack.push(Result);
								}
							}
						}
						else
							oTempStack.push(Right);
				}

				else
					//if(Result.id == JJTNOT) // operator is 'not';
					if(Result.toString().trim().equals("NOT"))
					{
						Result.type = 3;

						if(Right.getRank() == null)
							Result.setRank("");
						else
							Result.setRank(Right.getRank());
						//for rank [ not A ];

						//if(((SimpleNode)Result.parent).id == JJTASSIGN)
						if(((SimpleNode)Result.parent).toString().trim().equals("ASSIGN"))
							finish = true; //parent is "=",then finish;
						else //parent is logical symbol, if, at, push the result into temp stack;
							{
							temp_node = (SimpleNode)Result.parent;
							if((SimpleNode)temp_node.children[0] == Result)
								finish = check(Result, temp_node);
							else
								oTempStack.push(Result);
						}
					}

					else
						//if(((Result.id <= JJTNE) && (Result.id >= JJTOR))
							//|| (Result.id == JJTAND))
							//logical operator: <,>,<=,>=,==,!=, and, or;
						if((Result.toString().trim().equals("OR"))||(Result.toString().trim().equals("LT"))||
						   (Result.toString().trim().equals("GT"))||(Result.toString().trim().equals("GE"))||
						   (Result.toString().trim().equals("LE"))||(Result.toString().trim().equals("EQ"))||
						   (Result.toString().trim().equals("NE"))||(Result.toString().trim().equals("AND")))
						{
							if((SimpleNode)Result.children[0] == Right)
								//condition x+......
							{
								Left = Right;
								Right = (SimpleNode)oTempStack.pop();
								Result = (SimpleNode)Left.parent;
								Result.type = 3;

								Result.setRank(
									Right.getRank() + Left.getRank());
								if(Result == null)
									Result.setRank("");
								if(Result.getRank() != "")
									Result.setRank(Op_Str(Result.getRank()));
								//for rank[ A == ... and B]

								if((Left.type != Right.type)
									&& (Right.type != -1)
									&& (!again))
								{
									System.err.println(
										" Semantic error: "
											+ Left.getImage()
											+ " and "
											+ Right.getImage()
											+ " type does not match.");
									iErrorCount++;
								}
								//if(((SimpleNode)Result.parent).id== JJTASSIGN)
								if(((SimpleNode)Result.parent).toString().trim().equals("ASSIGN"))
									finish = true; //parent is "=",then finish;
								else //parent is logical symbol, if, at, push the result into temp stack;
									{
									temp_node = (SimpleNode)Result.parent;
									if((SimpleNode)temp_node.children[0]
										== Result)
										finish = check(Result, temp_node);
									else
										oTempStack.push(Result);
								}
							}
							else
								if(((SimpleNode)Result.children[0]).children
									== null)
									//condition: x+a*b or a+b+c ;
								{
									oSemanticStack.pop();
									Left = (SimpleNode)Result.children[0];
									//the left child
									Result.type = 3;

									Result.setRank(
										Right.getRank() + Left.getRank());
									if(Result.getRank() == null)
										Result.setRank("");
									if(Result.getRank() != "")
										Result.setRank(
											Op_Str(Result.getRank()));
									//for rank [A == ... and B]

									if((Left.type != Right.type)
										&& (Right.type != -1)
										&& (!again))
									{
										System.err.println(
											" Semantic error: "
												+ Left.getImage()
												+ " and "
												+ Right.getImage()
												+ " type does not match.");
										iErrorCount++;
									}
									//if(((SimpleNode)Result.parent).id== JJTASSIGN)
									if(((SimpleNode)Result.parent).toString().trim().equals("ASSIGN"))
										finish = true;
									//parent is "=",then finish;
									else //parent is logical symbol, if, at, push the result into temp stack;
										{
										temp_node = (SimpleNode)Result.parent;
										if((SimpleNode)temp_node.children[0]
											== Result)
											finish = check(Result, temp_node);
										else
											oTempStack.push(Result);
									}
								}
								else
									oTempStack.push(Right);
						}

						else
							//if(Result.id == JJTIF) //parent is 'if'
							if(Result.toString().trim().equals("IF"))
							{
								if((SimpleNode)Result.children[0] == Right) //
								{
									if((Right.type != 3) && (!again))
									{
										System.err.println(
											" Semantic error: "
												+ Right.getImage()
												+ " is not condition.");
										iErrorCount++;
									}
									temp_node = Right;
									if(oTempStack.size() < 2)
										finish = true;
									else
									{
										Left = (SimpleNode)oTempStack.pop();
										Right = (SimpleNode)oTempStack.pop();
										Result = (SimpleNode)Left.parent;

										if (!(Left.toString().indexOf(":")==-1))
										{
										//if(Left.id == JJTID)
										if(Left.toString().substring(0,Left.toString().indexOf(":")).trim().equals("ID"))
										{
											temp =
												(
													DictionaryItem)oDictionary
														.elementAt(
													Left.ID);
											if (temp.getType()==null) Left.type=-1;
											else Left.type = temp.getTypeEnumeration();
											if(temp.getRank() == null)
												Left.setRank("");
											else
												Left.setRank(temp.getRank());
										}
										}

										if (!(Right.toString().indexOf(":")==-1))
										{
										//if(Right.id == JJTID)
										if(Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID"))
										{
											temp =
												(
													DictionaryItem)oDictionary
														.elementAt(
													Right.ID);
											if (temp.getType()==null) Right.type=-1;
											else Right.type = temp.getTypeEnumeration();
											if(temp.getRank() == null)
												Right.setRank("");
											else
												Right.setRank(temp.getRank());
										}
										}

										Result.setRank(
											temp_node.getRank()
												+ Right.getRank()
												+ Left.getRank());
										//for rank[ if statement ]
										if(Result.getRank() == null)
											Result.setRank("");
										if(Result.getRank() != "")
											Result.setRank(
												Op_Str(Result.getRank()));

										if((Left.type != Right.type)
											&& (Right.type != -1))
										{
											Result.type = Left.type;
											//type don't match, give float type to if statement
											if(!again)
											{
												System.err.println(
													" Semantic error: If Statement's type do not match.");
												iErrorCount++;
											}
										}
										else
										{
											Result.type = Left.type;
										}
										//if(((SimpleNode)Result.parent).id== JJTASSIGN)
										if(((SimpleNode)Result.parent).toString().trim().equals("ASSIGN"))
											finish = true;
										//parent is "=",then finish;
										else //parent is logical symbol, if, at, push the result into temp stack;
											{
											temp_node =
												(SimpleNode)Result.parent;
											if((SimpleNode)temp_node
												.children[0]
												== Result)
												finish =
													check(Result, temp_node);
											else
												oTempStack.push(Result);
										}
									}
								}
								else
									oTempStack.push(Right);
							}

							else
								//if(Result.id == JJTAT) //parent is 'at'
								if(Result.toString().trim().equals("AT"))
								{								
									if((SimpleNode)Result.children[0]
										== Right)
										//
									{
										// add for rank [A @ .d N]
										if(Right.getRank() == null)
											Right.setRank("");
										if(Right.getRank() == "")
											Result.setRank("");
										else
										{
											Left =
												(SimpleNode)Result.children[1];
											R_str = Right.getRank();
											//L_str=Left.getImage();
											L_str = Integer.toString(Left.ID);
											int E_val = R_str.indexOf(L_str);
											if(E_val != -1)
											{
												if((R_str.length()
													- L_str.length())
													> 1)
													R_str =
														R_str.substring(
															0,
															E_val)
															+ R_str.substring(
																E_val
																	+ L_str
																		.length()
																	+ 2);
											}
											Result.setRank(R_str);
										}
										if(oTempStack.empty())
											finish = true;
										else
										{
											Right = (SimpleNode)oTempStack.pop();
											Result.type = Right.type;
											//if(((SimpleNode)Result.parent).id== JJTASSIGN)
											if(((SimpleNode)Result.parent).toString().trim().equals("ASSIGN"))
												finish = true;
											//parent is "=",then finish;
											else //parent is logical symbol, if, at, push the result into temp stack;
												{
												temp_node =
													(SimpleNode)Result.parent;
												if((SimpleNode)temp_node
													.children[0]
													== Result)
													finish =
														check(
															Result,
															temp_node);
												else
													oTempStack.push(Result);
											}
										}
									}
									else
										if((SimpleNode)Result.children[1]
											== Right)
										{
											int i2 = 1;
										  if (iCount==1)
										  {
											  found = false;
											  again = false;											  
										  }
										  else
										  {
											while(i2 < iCount)
											{
												temp =
													(
														DictionaryItem)oDictionary
															.elementAt(
														i2);
												if(temp
													.getName()
													.equals(Right.getImage()))
												{
													if((!temp
														.getKind()
														.equals("dimension"))
														&& (!again))
													{
														System.err.println(
															" Semantic error: "
																+ temp.getName()
																+ " is not dimension.");
														iErrorCount++;
													}
													else
													{
														Right.ID = temp.getID();
														i2 = iCount + 1;
														found = true;
													}
												}
												else
													i2++;
											}
										  }
											if((!found) && (!again))
											{
												System.err.println(
													" Semantic error: Dimension "
														+ Right.getImage()
														+ " is not defined.");
												iErrorCount++;
											}
										}
										else
											if((SimpleNode)Result.children[2]
												== Right)
											{
												finish = true;
												/*bRight=Result;
												Result=(SimpleNode)bRight.parent;
												finish=Check(bRight,Result);*/
											}
								}

								else
									//if(Result.id == JJTASSIGN) //parent is "="
									if(Result.toString().trim().equals("ASSIGN"))
									{
										if(((SimpleNode)Result.children[1]) == Right)
											//the type x=3;
										{
											if(!oSemanticStack.empty())
												Left = (SimpleNode)oSemanticStack.pop();
											//the left child
											else
											{
												finish = true;
												return finish;
											}
										}
										else
										{
											Left = Right;

											if((Left.ID < oDictionary.size()) && (Left.ID > 0))
											{
												temp = (DictionaryItem)oDictionary.elementAt(Left.ID);
												Right = temp.getEntry();
											}
											else
											{
												finish = true;
												return finish;
											}
										}

										((SimpleNode)Result.children[0]).type = Right.type;

										if((Left.ID < oDictionary.size()) && (Left.ID > 0))
											temp = (DictionaryItem)oDictionary.elementAt(Left.ID);
										else
										{
											finish = true;
											return finish;
										}

										if (!(Right.toString().indexOf(":")==-1))
										{
										//if(Right.id == JJTID)
										if(Right.toString().substring(0,Right.toString().indexOf(":")).trim().equals("ID"))
										{
											if((Right.ID > 0) && (Right.ID < oDictionary.size()))
												temp2 = (DictionaryItem)oDictionary.elementAt(Right.ID);
											else
											{
												finish = true;
												return finish;
											}

											Right.type = temp2.getTypeEnumeration();
											Right.setRank(temp2.getRank());
										}
										}

										temp.setType(Right.type);
										temp.setRank(Right.getRank());
										//for rank [X=...]

										if(temp.getRank() == null)
											temp.setRank("");

										if(temp.getRank() != "")
											temp.setRank(Op_Str(temp.getRank()));

										oDictionary.setElementAt(temp, Left.ID);
										finish = true;
									}//finish if "assign"
									else if (Result.toString().trim().equals("START"))
									//this is a special case for if reaching "start" some IPL code doesn't have declaration.
									{
										finish = true;
										again = false;
									}
										

		return finish;

	}

	/**
	 * Generates rank according to rank rules.
	 *
	 * @param str children's rank String.
	 * @return parents' rank String.
	 */
	public String Op_Str(String str)
	{
		String temp_str, First_str, Last_str = "";
		int len = 0;

		while(str.length() != 0)
		{
			if(str.indexOf(',') != -1)
			{
				temp_str = str.substring(0, str.indexOf(','));
				len = temp_str.length() + 1;
				str = str.substring(len);

				if(str.length() == 0)
					Last_str = Last_str + temp_str + ",";
				else
					if(str.indexOf(temp_str) == -1)
						Last_str = Last_str + temp_str + ",";
			}
			else
			{
				Last_str = Last_str + "";
				str = "";
			}
		}

		return Last_str;
	}

	/**
	 * Original design; now merges with the <code>traverseTree()</code> method.
	 * @see #traverseTree(SimpleNode)
	 */
	public void rankAnalyze(SimpleNode poRoot)
	{
		traverseTree(poRoot);
	}

	/**
	 * Return the number of errors found.
	 * @since Serguei
	 */
	public int getErrorCount()
	{
		return this.iErrorCount;
	}

	/**
	 * Return the number of warnings generated.
	 * @since Serguei
	 */
	public int getWarningCount()
	{
		return this.iWarningCount;
	}
}
