package gipsy.GIPC;

import gipsy.GIPC.intensional.SimpleNode;
import gipsy.storage.Dictionary;

import java.util.Vector;

/**
 * All semantic analyzers should implement this interface.
 * @author Serguei MoKhov
 * @version $Id: ISemanticAnalyzer.java,v 1.1 2013/08/25 02:59:29 mokhov Exp $
 */
public interface ISemanticAnalyzer {

	/**
	 * Gets the dictionary generated by semantic analyzer.
	 *
	 * @return Dictionary  the entry for the dictionary.
	 */
	Dictionary getDictionary();

	/**
	 * Builds the dictionary.
	 *
	 * @param address  start node of AST as the entry in the dictionary.
	 */
	void setupDictionary(SimpleNode address);

	/**
	 * Function operation.
	 *
	 *  Traverses the AST, encounters function node, gets the information and stores
	 *  it into a functions list table.
	 *
	 *  @param FunT  the entry used to be judge if it is a function node.
	 *  @param Sfn
	 * 
	 *  @see take(SimpleNode FunB).
	 *  @see eliminateFunction(SimpleNode begin, int Fcn).
	 *  @see Duplicate(SimpleNode root, SimpleNode Ori_tree, int Child_Num).
	 *  @see replace(SimpleNode ReTree, String dim[], Vector pl).
	 */
	void setFunction(SimpleNode FunT, int Sfn);

	/**
	 * Gets the parameters or dimensions for a function.
	 *
	 * @param FunB  simplenode type and used to gather information about parameters or dimension.
	 * @return simplenode type
	 */
	SimpleNode take(SimpleNode FunB);

	/**
	 * Uses real dimensions and parameters of a function to replace the definition
	 * of a function.
	 *
	 * @param ReTree the entry SimpleNode be replaced
	 * @param dim[] dimensions String
	 * @param pl  parameters Vector
	 */
	//void replace(SimpleNode ReTree, String dim[], Vector pl);
	void replace(SimpleNode ReTree, String dim[], Vector<SimpleNode> pl);

	/**
	 *  Set up dictionary.
	 *  Traverses a tree, analyzes the attributes of each identifier,
	 *  sets up the corresponding dictionary.
	 *
	 *  @param begin  entry SimpleNode of the tree will be traversed
	 *  @see SubTree1(SimpleNode tree1, DictionaryItem C_scope).
	 *  @see SubTree2(SimpleNode tree2, String N, int Num).
	 *  @see SubTree5(SimpleNode tree5, int Num5).
	 *  @see TS(SimpleNode T).
	 *  @see SubTree4(SimpleNode tree4, DictionaryItem current_scope).
	 *  @see int lookfor(String tree4).
	 *  @see boolean Conflict(String name).
	 */
	void traverseTree(SimpleNode begin);

	/**
	 *  Prints the identifier's ID and its name, for debugging.
	 *
	 *  @param T entry SimpleNode for a tree.
	 *  @author Paula
	 */
	void TS(SimpleNode T);

	/**
	 *  Checks whether the identifier names are conflict.
	 *
	 *  @param name  identifier String.
	 *  @return <code>true</code> the identifier is already defined.
	 *          <code>false</code> the identifier is not defined yet.
	 */
	boolean conflict(String name);

	/**
	 *  Type checking and rank analysis.
	 *  The core part of semantic analysis.
	 *
	 *  @see Check(SimpleNode bRight, SimpleNode Result).
	 */
	void typeCheck();

	/**
	 *  Traverses the tree, gets the result of the checking.
	 *
	 *  @param bRight bRight children SimpleNode
	 *  @param Result Parent SimpleNode
	 *  @return <code>true</code> result obeys rules.
	 *          <code>false</code> result abused rules.
	 */
	boolean check(SimpleNode Right, SimpleNode Result);

	/**
	 * Generates rank according to rank rules.
	 *
	 * @param str children's rank String.
	 * @return parents' rank String.
	 */
	String Op_Str(String str);

	/**
	 * Original design; now merges with the <code>traverseTree()</code> method.
	 * @see #traverseTree(SimpleNode)
	 */
	void rankAnalyze(SimpleNode poRoot);

	/**
	 * Return the number of errors found.
	 * @since Serguei
	 */
	int getErrorCount();

	/**
	 * Return the number of warnings generated.
	 * @since Serguei
	 */
	int getWarningCount();

}